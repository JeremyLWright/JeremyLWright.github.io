<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.89.2" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>C&#43;&#43;&nbsp;&ndash;&nbsp;The Quiescent Current</title><link rel="stylesheet" href="/css/core.min.6794bc167e4ce0026d21831c61e605e88a70ef6cc11b090df06de3ed8be76f69afa57c9dcd7ba7210c777e124e943258.css" integrity="sha384-Z5S8Fn5M4AJtIYMcYeYF6Ipw72zBGwkN8G3j7Yvnb2mvpXydzXunIQx3fhJOlDJY"><link rel="alternate" type="application/rss+xml" href="/languages/c++/index.xml" title="The Quiescent Current" /><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="C&#43;&#43;" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">The Quiescent Current</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="/posts">Blog</a><a class="nav item" href="/series">Series</a><a class="nav item" href="/languages">Languages</a><a class="nav item" href="/about">About</a></nav></div></span></div><div class="site slogan"><span class="title">Go Far. Go Together.</span></div></section><section id="content"><section class="article header"><h1>C&#43;&#43;</h1></section><ul class="note list"><li class="item"><a class="note" href="/2015/10/system-languages-include-web/">
            <p class="note title">System languages should include Webapps</p><p class="note date">Saturday, October 3, 2015</p><p class="note content">I was reading an FAQ today about some subtle C++ point and I came across a comment that explicitly excludes the beginning language-learner.
 By the way, it confuses most novice C++ programmers that private virtuals can be overridden&hellip; However the private virtual approach is now common enough that confusion of novices is less of a concern.
 This left me frustrated that a language that has been core to my personal success so flippantly brushed aside its future user.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/coding/">Coding</a></p></li><li class="item"><a class="note" href="/2015/02/introduction-to-pointers/">
            <p class="note title">Introduction to Pointers</p><p class="note date">Tuesday, February 17, 2015</p><p class="note content">Please see my introduction to pointers at https://www.youtube.com/watch?v=mkYBz5Db-Ok .</p></a><p class="note labels"><a class="tag" href="/tags/beginner/">Beginner</a></p></li><li class="item"><a class="note" href="/2013/11/sean-parent-no-raw-loops/">
            <p class="note title">Sean Parent: No Raw Loops</p><p class="note date">Sunday, November 24, 2013</p><p class="note content">A group of colleagues and I watched Sean Parent&rsquo;s Going Native Talk on &ldquo;C++ Seasoning &rdquo;. Parent takes some extreme views on how to use C++, but his examples for using the STL to simplify code are phenomenal. For a recent AI project I decided to apply Parent&rsquo;s goal of &ldquo;no raw loops&rdquo;, I was blown away by the transformation&hellip; err std::transformation this had on my code. In this post I indented to demonstrate several complex code blocks, or overly specific code blocks what were replaced by some STL magic. Alexander Stepanov says, &ldquo;&hellip;code is a liability. &rdquo; The more code a program has the more likely it contains bugs. The fewer lines of code, the lesser the opportunity for a bug. I haven&rsquo;t quiet decided if I agree with this point, but it does induce thought either way. Sean Parent&rsquo;s methodology seems to agree, for the purposes of this post we&rsquo;ll agree as well.
<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/productivity/">Productivity</a><a class="tag" href="/tags/c&#43;&#43;11/">C&#43;&#43;11</a><a class="tag" href="/tags/stepanov/">Stepanov</a><a class="tag" href="/tags/stl/">STL</a></p></li><li class="item"><a class="note" href="/2013/10/idiomatic-learning/">
            <p class="note title">Idiomatic Learning</p><p class="note date">Sunday, October 20, 2013</p><p class="note content">When learning a new language I find it helpful to study a languages idioms. Idioms exist in a language for a specific reason. Sometimes that reason is to further the principles of the language, other times it’s to mask, or otherwise deal with some underlying design decision of the language. Currently, I am studying Haskell, and currently I am struggle to clarify the idioms of the language. The syntax is still very new and awkward, currently with a total authoring in Haskell of 713 lines.
<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/idiom/">Idiom</a></p></li><li class="item"><a class="note" href="/2013/07/is-monolithic-code-faster/">
            <p class="note title">Is Monolithic Code Faster?</p><p class="note date">Sunday, July 14, 2013</p><p class="note content">As a software engineer I have a vested interest in disproving this statement. Bjarne Stroustroup says C++ is designed to create efficient abstractions. A software engineer’s job is to create simple abstractions  to complex systems. State machines form a large part of many systems. The other day, a co-worker came to me, and asked, “Is it better to make straight line code for each case statement, even if it repeats, or is it better to abstraction into functions and make the code ‘cleaner’.” Is “cleaner” code faster?
<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/compilation/">Compilation</a><a class="tag" href="/tags/optimization/">optimization</a><a class="tag" href="/tags/performance/">performance</a></p></li><li class="item"><a class="note" href="/2012/07/know-its-name/">
            <p class="note title">Know Its Name</p><p class="note date">Saturday, July 21, 2012</p><p class="note content">Programming is at it&rsquo;s heart an struggle in communication. Source code is the communication medium with the processor; Comment the medium to other coders, and UML the medium to higher-level communication. Computer Scientists have the stereotype of being poor communicators, but in our own mediums, we&rsquo;re phenomenal. This fact is no where more apparent, than trying to explain source code to someone else. How does one read source code? I&rsquo;m currently, learning Haskell, and my first goal is to understand this question.<span class="mldr">&mldr;</span></p></a></li><li class="item"><a class="note" href="/2012/03/multicast-delegates-in-c11/">
            <p class="note title">Multicast Delegates in C++11</p><p class="note date">Sunday, March 25, 2012</p><p class="note content">C# has a wonderfully flexible delegate system capable of multicast events. This simple tool makes event driven software easier to write, and reduces coupling between objects. In 2003 Herb Sutter implemented a general form of the Observer pattern [1]. He called this the multi_function. It uses a mixture of TR1 and boost components to build a multi-cast delegate similar to C#&rsquo;s. Fast-forward 9 years, and we now have variadic-templates thanks to C++11. Variadic-Templates allow us to patch a missing component in Sutter&rsquo;s multi_function.
<span class="mldr">&mldr;</span></p></a></li><li class="item"><a class="note" href="/2012/02/compile-time-polymorphism/">
            <p class="note title">Compile-Time Polymorphism</p><p class="note date">Sunday, February 5, 2012</p><p class="note content">Polymorphism is a tool in object orientation, which allows us to model behavior, while simultaneously leverage existing code. Polymorphism allows is behavior reuse. In C++ polymorphism, comes in 2 flavors, the standard runtime variant, and a curious compile time variant. Runtime polymorphism, like Java, leverages virtual functions to dynamically bind[1. With virtual functions the compiler doesn&rsquo;t know which method to call until runtime. In C++ this is implemented with the virtual method table ] a method at the call site. Compile Time polymorphism uses templates, to bind at compile time, thus negating the performance affect of virtual functions.
<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/coding/">Coding</a><a class="tag" href="/tags/idiom/">idiom</a><a class="tag" href="/tags/performance/">performance</a><a class="tag" href="/tags/template/">template</a><a class="tag" href="/tags/virtual/">virtual</a></p></li><li class="item"><a class="note" href="/2011/11/parallel-binary-buddy-the-friendly-memory-manager/">
            <p class="note title">Parallel Binary Buddy: The Friendly Memory Manager</p><p class="note date">Wednesday, November 23, 2011</p><p class="note content">Fragmentation, the allocator&rsquo;s sin. Each byte A buddy, A friend
<span class="mldr">&mldr;</span></p></a></li><li class="item"><a class="note" href="/2011/10/making-c-like-python-the-anderson-smart-pointer-pattern/">
            <p class="note title">Making C++ like Python: The Anderson Smart Pointer Pattern</p><p class="note date">Sunday, October 23, 2011</p><p class="note content">Choosing to use C++ brings the additional complexity of memory management. Dennis Ritchie once stated: The C Programming Language — A language which combines the flexibility of assembly language with the power of assembly language. C++ inherits much of that _flexibility, _however, this incidental complexity , can be relegated to a single class, leaving you with the high-level elegance of Python. RAII help with this additional complexity, however without a pattern for guidance implementing RAII consistently can be difficult, defeating the safety it provides.
<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/coding/">Coding</a><a class="tag" href="/tags/memory/">memory</a><a class="tag" href="/tags/python/">Python</a><a class="tag" href="/tags/raii/">RAII</a></p></li></ul><div class="pagination">
    <ul><li><a class="active" href="/languages/c&#43;&#43;/">1</a></li><li><a class="" href="/languages/c&#43;&#43;/page/2/">2</a></li></ul>
</div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">©2021 Jeremy Wright</p>
    <p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div>
</section><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/&#43;DiW/UqRcLbRjq" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l&#43;B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd&#43;qj&#43;o24G5ZU2zJz" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
            onload="renderMathInElement(document.body);"></script></body>

</html>