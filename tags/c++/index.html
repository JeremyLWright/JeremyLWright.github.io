<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.97.3" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>C&#43;&#43;&nbsp;&ndash;&nbsp;The Quiescent Current</title><link rel="stylesheet" href="/css/core.min.6794bc167e4ce0026d21831c61e605e88a70ef6cc11b090df06de3ed8be76f69afa57c9dcd7ba7210c777e124e943258.css" integrity="sha384-Z5S8Fn5M4AJtIYMcYeYF6Ipw72zBGwkN8G3j7Yvnb2mvpXydzXunIQx3fhJOlDJY"><link rel="alternate" type="application/rss+xml" href="/tags/c++/index.xml" title="The Quiescent Current" /><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="C&#43;&#43;" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">The Quiescent Current</span></a></span>
        <span class="header right-side"></span></div><div class="site slogan"><span class="title">Go Far. Go Together.</span></div></section><section id="content"><section class="article header"><h1>C&#43;&#43;</h1></section><ul class="note list"><li class="item"><a class="note" href="/2015/07/property_driven_design_minmax/">
            <p class="note title">Property Driven Design: MinMax</p><p class="note date">Sunday, July 5, 2015</p><p class="note content">I wrote an article on Property Testing about a year ago. Isocpp.org even linked to it which was pretty cool. Recently, I uncovered a fantastic talk by Jessica Kerr about property testing . Kerr&rsquo;s talk reinvigorated my languid research effort toward generated testing. Kerr presented the idea (novel to me) that properties aren&rsquo;t rigid. Properties don&rsquo;t need to exclude all possible incorrect results for a given function. Properties simply must reduce the size of the incorrect space. This may seem like semantics, but it is easier to exclude a wild-ass-guess that verify it is correct. Additionally, some domains may not have a solidly defined answer,a nd the result my be probabilistic in nature. This post will focus on deterministic problems for the moment, but realize that property testing is vastly more general than mundane example testing. How properties reduce the size of the problem space makes me imagine this Figure.
Following Kerr&rsquo;s references, I found a set of projects from a predicate-logic course . This course provides 20 separate projects excellently cast for a property-driven-design tutorial. These projects are unique since besides the typical requirements they enumerate the predicate functions each requirement typifies. Predicate functions are to a predicate-logician as properties are to a computer scientist. These enumerated properties (predicates) clarified many points I misunderstood about property testing.
This post will step through the design of the first project minmax using C++. My primary goal for this article is to address a concern raised by a colleague, &ldquo;Does pulling in more complexity — a fancy test generator — actually increase quality?&rdquo;
 Code for this article . Revision Log for this article  <span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/c&#43;&#43;/">C&#43;&#43;</a><a class="tag" href="/tags/property-driven-design/">Property Driven Design</a><a class="tag" href="/tags/property-testing/">property-testing</a><a class="tag" href="/tags/example/">example</a><a class="tag" href="/tags/tutorial/">tutorial</a></p></li><li class="item"><a class="note" href="/2014/09/property-testing-in-c/">
            <p class="note title">Property Testing in C++</p><p class="note date">Wednesday, September 3, 2014</p><p class="note content">Currently, I'm on a testing kick. One might say tests are shiny. I don'tknow if they are really shiny as much as I found another cool use foruniform_int_distribution. A use which, as a side effect, might make meappear to be a better software developer. (This assumes a negative bug rate isproportional to better software). I've started playing with Property Testing.Property Testing is a form of unit testing where the programmers definesproperties, or invariants about the code. A framework library (ok,seriously its a framework because it calls your code) generates randomconstrained inputs and calls your test functions. It's pretty cool, and whileI was playing around with the framework, I found a real bug, related to myignorance of C++'s auto type deduction.
<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/c&#43;&#43;/">c&#43;&#43;</a><a class="tag" href="/tags/unit-test/">unit test</a></p></li><li class="item"><a class="note" href="/2014/02/cracking-subciphercpp/">
            <p class="note title">Massively Intelligent Non-Deterministic Luminating Effortless Super Solver</p><p class="note date">Wednesday, February 12, 2014</p><p class="note content">I worked the title of this article several times before I finally settled on the subtly epic heading you see above. Hopefully this title will funnel people off google into my blog (delicious SEO). I wanted to push the A.I. component of my solution because A.I. is awesome and mysterious, and cool (and can like solve jeopardy). I was quickly disillusioned however. Really, A.I. isn&rsquo;t magic, rather it&rsquo;s just the same thing computers have been doing for a long time: computing. Sadly this realization took several months in an A.I. class before I was sufficiently crestfallen. A.I. patterns including the hill climbing algorithm used here are indeed &ldquo;intelligent&rdquo; but really it a reflecting of the algorithm designer, not the entity executing the algorithm. So I built a substitution cipher solver in C++. It&rsquo;s fast it uses random numbers i.e. non-deterministic, it uses an A.I. algorithm i.e. Intelligent, it uses threads i.e. Massively, it deciphers i.e. luminates the text and it solves super stuff therefore the title is completely justified. I give you my Massively Intelligent Non-Deterministic Luminating Effortless Super Solver (MINDLESS). If none of that interests you then please stick around and follow the side quest of looking for emotionally charged parenthesis.
<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/c&#43;&#43;/">c&#43;&#43;</a><a class="tag" href="/tags/c&#43;&#43;11/">c&#43;&#43;11</a><a class="tag" href="/tags/cipher/">cipher</a><a class="tag" href="/tags/cryptogram/">cryptogram</a><a class="tag" href="/tags/crytography/">crytography</a><a class="tag" href="/tags/monoalphabetic/">monoalphabetic</a><a class="tag" href="/tags/substitution-cipher/">substitution cipher</a></p></li><li class="item"><a class="note" href="/2012/05/building-an-interpreter/">
            <p class="note title">Building an Interpreter</p><p class="note date">Monday, May 28, 2012</p><p class="note content">When I started programming, I thought that compilers where these magic behemoths; Oracles which consumed your source code, and prophesied the resulting program. I thought that the compiler was an integral part of the &ldquo;system&rdquo;. I was excited to realize that the compiler is simply another program. A program you can write yourself. You can write a compiler, for your very own language. Go ahead, make up a language, I&rsquo;ll wait&hellip;
 Seriously though, making your own language is a very difficult task, and implementing a language useful enough for non-trivial problems is even more difficult. There is however, a very approachable goal here: Domain Specific Languages (DSLs). DSLs are focused languages useful to a limited group of people for a limited purpose.
I like to think of DSLs as tools. For example, sometimes one needs to automate a task, its might be easier to write a small program that helps with that task. But it might be even more useful to write a language that allows you to describe the problem better, then one can write a program using the new language to finish the task in an efficient and repeatable way. The program has limited usefulness beyond its initial application, but for the application at hand, its perfect. SQL is the canonical example. In this post we&rsquo;ll start with a basic grammar in EBNF. We&rsquo;ll translate that to a flex lexer, and connect that to a bison parser. We&rsquo;ll end up with a syntax tree which we&rsquo;ll execute to calculate a result.
<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/compilation/">Compilation</a><a class="tag" href="/tags/ast/">AST</a><a class="tag" href="/tags/bison/">Bison</a><a class="tag" href="/tags/c&#43;&#43;/">C&#43;&#43;</a><a class="tag" href="/tags/compiler/">compiler</a><a class="tag" href="/tags/flex/">Flex</a></p></li></ul></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">©2022 Jeremy Wright</p>
    <p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div>
</section><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/&#43;DiW/UqRcLbRjq" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l&#43;B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd&#43;qj&#43;o24G5ZU2zJz" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
            onload="renderMathInElement(document.body);"></script></body>

</html>