<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C&#43;&#43; on The Quiescent Current</title>
    <link>/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on The Quiescent Current</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>©2020 Jeremy Wright</copyright>
    <lastBuildDate>Sat, 03 Oct 2015 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>System languages should include Webapps</title>
      <link>/2015/10/system-languages-include-web/</link>
      <pubDate>Sat, 03 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>/2015/10/system-languages-include-web/</guid>
      <description>I was reading an FAQ today about some subtle C++ point and I came across a comment that explicitly excludes the beginning language-learner.
 By the way, it confuses most novice C++ programmers that private virtuals can be overridden&amp;hellip; However the private virtual approach is now common enough that confusion of novices is less of a concern.
 This left me frustrated that a language that has been core to my personal success so flippantly brushed aside its future user.</description>
      
    </item>
    
    <item>
      <title>Property Testing in C&#43;&#43;</title>
      <link>/2014/09/property-testing-in-c/</link>
      <pubDate>Wed, 03 Sep 2014 23:00:00 -0700</pubDate>
      
      <guid>/2014/09/property-testing-in-c/</guid>
      <description>&lt;!-- raw HTML omitted --&gt;</description>
      
    </item>
    
    <item>
      <title>Massively Intelligent Non-Deterministic Luminating Effortless Super Solver</title>
      <link>/2014/02/cracking-subciphercpp/</link>
      <pubDate>Wed, 12 Feb 2014 08:50:00 -0700</pubDate>
      
      <guid>/2014/02/cracking-subciphercpp/</guid>
      <description>&lt;p&gt;I worked the title of this article several times before I finally settled on the subtly epic heading you see above. Hopefully this title will funnel people off google into my blog (delicious SEO). I wanted to push the A.I. component of my solution because A.I. is awesome and mysterious, and cool (and can like solve jeopardy). I was quickly disillusioned however. Really, A.I. isn&amp;rsquo;t magic, rather it&amp;rsquo;s just the same thing computers have been doing for a long time: computing. Sadly this realization took several months in an A.I. class before I was sufficiently crestfallen. A.I. patterns including the hill climbing algorithm used here are indeed &amp;ldquo;intelligent&amp;rdquo; but really it a reflecting of the algorithm designer, not the entity executing the algorithm. So I built a substitution cipher solver in C++. It&amp;rsquo;s fast it uses random numbers i.e. non-deterministic, it uses an A.I. algorithm i.e. Intelligent, it uses threads i.e. Massively, it deciphers i.e. luminates the text and it solves super stuff therefore the title is completely justified. I give you my Massively Intelligent Non-Deterministic Luminating Effortless Super Solver (MINDLESS). If none of that interests you then please stick around and follow the side quest of looking for &lt;!-- raw HTML omitted --&gt;emotionally charged parenthesis&lt;!-- raw HTML omitted --&gt;.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Sean Parent: No Raw Loops</title>
      <link>/2013/11/sean-parent-no-raw-loops/</link>
      <pubDate>Sun, 24 Nov 2013 22:14:50 +0000</pubDate>
      
      <guid>/2013/11/sean-parent-no-raw-loops/</guid>
      <description>A group of colleagues and I watched Sean Parent&amp;rsquo;s Going Native Talk on &amp;ldquo;C++ Seasoning&amp;rdquo;. Parent takes some extreme views on how to use C++, but his examples for using the STL to simplify code are phenomenal. For a recent AI project I decided to apply Parent&amp;rsquo;s goal of &amp;ldquo;no raw loops&amp;rdquo;, I was blown away by the transformation&amp;hellip; err std::transformation this had on my code. In this post I indented to demonstrate several complex code blocks, or overly specific code blocks what were replaced by some STL magic.</description>
      
    </item>
    
    <item>
      <title>Idiomatic Learning</title>
      <link>/2013/10/idiomatic-learning/</link>
      <pubDate>Sun, 20 Oct 2013 23:00:00 +0000</pubDate>
      
      <guid>/2013/10/idiomatic-learning/</guid>
      <description>When learning a new language I find it helpful to study a languages idioms. Idioms exist in a language for a specific reason. Sometimes that reason is to further the principles of the language, other times it’s to mask, or otherwise deal with some underlying design decision of the language. Currently, I am studying Haskell, and currently I am struggle to clarify the idioms of the language. The syntax is still very new and awkward, currently with a total authoring in Haskell of 713 lines.</description>
      
    </item>
    
    <item>
      <title>Is Monolithic Code Faster?</title>
      <link>/2013/07/is-monolithic-code-faster/</link>
      <pubDate>Sun, 14 Jul 2013 23:00:11 +0000</pubDate>
      
      <guid>/2013/07/is-monolithic-code-faster/</guid>
      <description>As a software engineer I have a vested interest in disproving this statement. Bjarne Stroustroup says C++ is designed to create efficient abstractions. A software engineer’s job is to create simple abstractions to complex systems. State machines form a large part of many systems. The other day, a co-worker came to me, and asked, “Is it better to make straight line code for each case statement, even if it repeats, or is it better to abstraction into functions and make the code ‘cleaner’.</description>
      
    </item>
    
    <item>
      <title>Know Its Name</title>
      <link>/2012/07/know-its-name/</link>
      <pubDate>Sat, 21 Jul 2012 19:24:19 +0000</pubDate>
      
      <guid>/2012/07/know-its-name/</guid>
      <description>Programming is at it&amp;rsquo;s heart an struggle in communication. Source code is the communication medium with the processor; Comment the medium to other coders, and UML the medium to higher-level communication. Computer Scientists have the stereotype of being poor communicators, but in our own mediums, we&amp;rsquo;re phenomenal. This fact is no where more apparent, than trying to explain source code to someone else. How does one read source code? I&amp;rsquo;m currently, learning Haskell, and my first goal is to understand this question.</description>
      
    </item>
    
    <item>
      <title>Building an Interpreter</title>
      <link>/2012/05/building-an-interpreter/</link>
      <pubDate>Mon, 28 May 2012 17:03:55 +0000</pubDate>
      
      <guid>/2012/05/building-an-interpreter/</guid>
      <description>When I started programming, I thought that compilers where these magic behemoths; Oracles which consumed your source code, and prophesied the resulting program. I thought that the compiler was an integral part of the &amp;ldquo;system&amp;rdquo;. I was excited to realize that the compiler is simply another program. A program you can write yourself. You can write a compiler, for your very own language. Go ahead, make up a language, I&amp;rsquo;ll wait&amp;hellip;</description>
      
    </item>
    
    <item>
      <title>Anderson Smart-Pointer Idiom Updated!</title>
      <link>/2012/05/anderson-smart-pointer-idiom-updated/</link>
      <pubDate>Sun, 06 May 2012 07:00:10 +0000</pubDate>
      
      <guid>/2012/05/anderson-smart-pointer-idiom-updated/</guid>
      <description>C++11 provides us with a ton of new tools for expressing complex ideas in an efficient way. C++11 is unique among modern languages in that it provides a productive syntax, while also generating exceptionally fast code. For the first time ever, software engineers are responsible for increasing the performance of software systems. For decades we&amp;rsquo;ve been standing on the shoulders of hardware engineers. Hardware engineers have been increasing the clock speeds of our processors, but we&amp;rsquo;ve hit a physical limit.</description>
      
    </item>
    
    <item>
      <title>Multicast Delegates in C&#43;&#43;11</title>
      <link>/2012/03/multicast-delegates-in-c11/</link>
      <pubDate>Sun, 25 Mar 2012 05:32:43 +0000</pubDate>
      
      <guid>/2012/03/multicast-delegates-in-c11/</guid>
      <description>C# has a wonderfully flexible delegate system capable of multicast events. This simple tool makes event driven software easier to write, and reduces coupling between objects. In 2003 Herb Sutter implemented a general form of the Observer pattern [1]. He called this the multi_function. It uses a mixture of TR1 and boost components to build a multi-cast delegate similar to C#&amp;rsquo;s. Fast-forward 9 years, and we now have variadic-templates thanks to C++11.</description>
      
    </item>
    
    <item>
      <title>Compile-Time Polymorphism</title>
      <link>/2012/02/compile-time-polymorphism/</link>
      <pubDate>Sun, 05 Feb 2012 21:14:29 +0000</pubDate>
      
      <guid>/2012/02/compile-time-polymorphism/</guid>
      <description>Polymorphism is a tool in object orientation, which allows us to model behavior, while simultaneously leverage existing code. Polymorphism allows is behavior reuse. In C++ polymorphism, comes in 2 flavors, the standard runtime variant, and a curious compile time variant. Runtime polymorphism, like Java, leverages virtual functions to dynamically bind[1. With virtual functions the compiler doesn&amp;rsquo;t know which method to call until runtime. In C++ this is implemented with the virtual method table] a method at the call site.</description>
      
    </item>
    
    <item>
      <title>Modern C&#43;&#43;</title>
      <link>/2012/01/modern-c/</link>
      <pubDate>Sun, 22 Jan 2012 18:10:30 +0000</pubDate>
      
      <guid>/2012/01/modern-c/</guid>
      <description>I found an awesome talk on how the new changes of C++11 are modernizing, an already fantastically powerful language. http://channel9.msdn.com/Events/BUILD/BUILD2011/TOOL-835T.
In this talk, Herb Sutter does two things I feel are quite admirable. Firstly, despite this being a Microsoft conference, he talks only about standard, portable C++ until the final minutes.
Secondly, he very clearly, compares idioms we currently use, to the new C++11 idioms. This made it very easy for me to see the value of what C++11 provides.</description>
      
    </item>
    
    <item>
      <title>Parallel Binary Buddy: The Friendly Memory Manager</title>
      <link>/2011/11/parallel-binary-buddy-the-friendly-memory-manager/</link>
      <pubDate>Wed, 23 Nov 2011 18:50:20 +0000</pubDate>
      
      <guid>/2011/11/parallel-binary-buddy-the-friendly-memory-manager/</guid>
      <description>Fragmentation, the allocator&amp;rsquo;s sin. Each byte A buddy, A friend
 Introduction
Memory management is pervasive in all forms of software, not just operating systems. Embedded Systems, when dynamic memory is acceptable, tend to use memory pools to the heap. Standard desktop applications use the platform&amp;rsquo;s std::new or malloc. However, when a system is more complex, a memory manager may be used. Memory managers allow the programmer to strictly control application memory, in a way that flows with the rest of the system&amp;rsquo;s design.</description>
      
    </item>
    
    <item>
      <title>Making C&#43;&#43; like Python: The Anderson Smart Pointer Pattern</title>
      <link>/2011/10/making-c-like-python-the-anderson-smart-pointer-pattern/</link>
      <pubDate>Sun, 23 Oct 2011 19:00:21 +0000</pubDate>
      
      <guid>/2011/10/making-c-like-python-the-anderson-smart-pointer-pattern/</guid>
      <description>Choosing to use C++ brings the additional complexity of memory management. Dennis Ritchie once stated: The C Programming Language — A language which combines the flexibility of assembly language with the power of assembly language. C++ inherits much of that _flexibility, _however, this incidental complexity, can be relegated to a single class, leaving you with the high-level elegance of Python. RAII help with this additional complexity, however without a pattern for guidance implementing RAII consistently can be difficult, defeating the safety it provides.</description>
      
    </item>
    
    <item>
      <title>Parallel Game-of-Life</title>
      <link>/2011/10/parallel-game-of-life/</link>
      <pubDate>Sun, 23 Oct 2011 17:55:47 +0000</pubDate>
      
      <guid>/2011/10/parallel-game-of-life/</guid>
      <description>Conway&amp;rsquo;s Game of Life is a dramatic illustration of emmergent behavior; that a seemingly complex system, such as cell mitosis can be governed by a set of simple rules. OpenMP is a fantastic set of language extensions which allows one to add dramatic parallelism without complex thread management. As a demonstration of OpenMP&amp;rsquo;s simplicity I implemented the Game of Life. The code and all analysis is available on bitbucket.org.
In a real program, it common to have swathes of code which cannot be made parallel.</description>
      
    </item>
    
    <item>
      <title>Good Tools, Excellent Results</title>
      <link>/2011/08/good-tools-excellent-results/</link>
      <pubDate>Sun, 21 Aug 2011 07:23:25 +0000</pubDate>
      
      <guid>/2011/08/good-tools-excellent-results/</guid>
      <description>This semester for the C++ practicum we are building a clone of Zork. Like many games of the genre, Zork is driven by a database. Our implementation is a JSON database. I chose JSON for a few reasons, but most importantly because its a human readable format that&amp;rsquo;s simple to understand. I started by editing JSON files by hand in a text editor, however I found very quickly that investigating in a quick tool greatly improved my quality.</description>
      
    </item>
    
    <item>
      <title>D for the C&#43;&#43; Programmer</title>
      <link>/2011/05/d-for-the-c-programmer-red-black-tree-part-3/</link>
      <pubDate>Wed, 18 May 2011 03:06:36 +0000</pubDate>
      
      <guid>/2011/05/d-for-the-c-programmer-red-black-tree-part-3/</guid>
      <description>As a comparative study, I am porting a Red-Black Tree from C++ to the D programming language (Part 1, Part 2). Overall D is an easy, practical transition for the C++ programmer. D provides a number of features for implementing correct code, however it is D’s simplicity that makes it truly enticing as a replacement. While D retains _C Style Syntax, _it is considerably simpler than C++, especially in the presence of exceptions.</description>
      
    </item>
    
    <item>
      <title>The Red-Black Tree</title>
      <link>/2011/05/the-red-black-tree-part-1/</link>
      <pubDate>Mon, 09 May 2011 06:59:01 +0000</pubDate>
      
      <guid>/2011/05/the-red-black-tree-part-1/</guid>
      <description>C++ Source Code D Source Code
D provides a number of features that simplify designing software, especially in the embedded environment. I will show in this 2 part comparison, between C++ and D, that D helps one write correct code. Correct code is something Andrei Alexandrescu, stresses heavily as a prominent feature of D. I use the Red-Black Tree for such a comparison since its complicated enough to make memory management difficult, while retaining real-world application.</description>
      
    </item>
    
  </channel>
</rss>
