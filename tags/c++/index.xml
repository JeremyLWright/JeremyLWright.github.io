<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on The Quiescent Current</title>
    <link>https://quiescent.us/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on The Quiescent Current</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>©2022 Jeremy Wright</copyright>
    <lastBuildDate>Sun, 05 Jul 2015 00:00:00 +0000</lastBuildDate><atom:link href="https://quiescent.us/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Property Driven Design: MinMax</title>
      <link>https://quiescent.us/2015/07/property_driven_design_minmax/</link>
      <pubDate>Sun, 05 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://quiescent.us/2015/07/property_driven_design_minmax/</guid>
      <description>&lt;p&gt;I wrote an article on &lt;a href=&#34;http://www.codestrokes.com/2014/09/property-testing-in-c/&#34;&gt;Property Testing&lt;/a&gt;
about a year ago. Isocpp.org even &lt;a href=&#34;https://isocpp.org/blog/2014/12/property-testing&#34;&gt;linked to
it&lt;/a&gt; which was pretty cool.
Recently, I uncovered a fantastic talk by &lt;a href=&#34;https://www.youtube.com/watch?v=shngiiBfD80&#34;&gt;Jessica Kerr about property
testing&lt;/a&gt;. Kerr&amp;rsquo;s talk
reinvigorated my languid research effort toward generated testing. Kerr
presented the idea (novel to me) that properties aren&amp;rsquo;t rigid. Properties
don&amp;rsquo;t need to exclude all possible incorrect results for a given function.
Properties simply must &lt;em&gt;reduce the size&lt;/em&gt; of the incorrect space. This may seem
like semantics, but it is easier to exclude a wild-ass-guess that verify it is correct.
Additionally, some domains may not have a solidly defined answer,a nd the
result my be probabilistic in nature. This post will focus on deterministic
problems for the moment, but realize that property testing is vastly more
general than mundane example testing. How properties reduce the size of the
problem space makes me imagine this Figure.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://quiescent.us/img/Properties_solution_space.png&#34; alt=&#34;sometimes_code_gives_you_a_wtf&#34;&gt;&lt;/p&gt;
&lt;p&gt;Following Kerr&amp;rsquo;s references, I found a set of projects from a &lt;a href=&#34;http://www.cs.ou.edu/~rlpage/SEcollab/20projects/&#34;&gt;predicate-logic
course&lt;/a&gt;. This course
provides 20 separate projects excellently cast for a property-driven-design
tutorial. These projects are unique since besides the typical requirements
they enumerate the predicate functions each requirement typifies. Predicate
functions are to a predicate-logician as properties are to a computer
scientist. These enumerated properties (predicates) clarified
many points I misunderstood about property testing.&lt;/p&gt;
&lt;p&gt;This post will step through the design of the first project
&lt;a href=&#34;http://www.cs.ou.edu/~rlpage/SEcollab/20projects/minmax.htm&#34;&gt;minmax&lt;/a&gt; using
C++. My primary goal for this article is to address a concern raised by
a colleague, &amp;ldquo;Does pulling in more complexity — a fancy test
generator — actually increase quality?&amp;rdquo;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/JeremyLWright/property_driven_design/tree/master/01_minmax&#34;&gt;Code for this article&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/JeremyLWright/JeremyLWright.github.io/commits/content/content/posts/2015-07-05-property_driven_design_minmax.markdown&#34;&gt;Revision Log for this article&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Property Testing in C&#43;&#43;</title>
      <link>https://quiescent.us/2014/09/property-testing-in-c/</link>
      <pubDate>Wed, 03 Sep 2014 23:00:00 -0700</pubDate>
      
      <guid>https://quiescent.us/2014/09/property-testing-in-c/</guid>
      <description>&lt;p&gt;
Currently, I&#39;m on a testing kick. One might say tests are shiny. I don&#39;t
know if they are really shiny as much as I found another cool use for
uniform_int_distribution&lt;&gt;. A use which, as a side effect, might make me
appear to be a better software developer. (This assumes a negative bug rate is
proportional to better software). I&#39;ve started playing with Property Testing.
Property Testing is a form of unit testing where the programmers defines
properties, or invariants about the code. A &lt;del&gt;framework&lt;/del&gt; library (ok,
seriously its a framework because it calls your code) generates random
constrained inputs and calls your test functions. It&#39;s pretty cool, and while
I was playing around with the framework, I found a real bug, related to my
ignorance of C++&#39;s auto type deduction.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Massively Intelligent Non-Deterministic Luminating Effortless Super Solver</title>
      <link>https://quiescent.us/2014/02/cracking-subciphercpp/</link>
      <pubDate>Wed, 12 Feb 2014 08:50:00 -0700</pubDate>
      
      <guid>https://quiescent.us/2014/02/cracking-subciphercpp/</guid>
      <description>&lt;p&gt;I worked the title of this article several times before I finally settled on the subtly epic heading you see above. Hopefully this title will funnel people off google into my blog (delicious SEO). I wanted to push the A.I. component of my solution because A.I. is awesome and mysterious, and cool (and can like solve jeopardy). I was quickly disillusioned however. Really, A.I. isn&amp;rsquo;t magic, rather it&amp;rsquo;s just the same thing computers have been doing for a long time: computing. Sadly this realization took several months in an A.I. class before I was sufficiently crestfallen. A.I. patterns including the hill climbing algorithm used here are indeed &amp;ldquo;intelligent&amp;rdquo; but really it a reflecting of the algorithm designer, not the entity executing the algorithm. So I built a substitution cipher solver in C++. It&amp;rsquo;s fast it uses random numbers i.e. non-deterministic, it uses an A.I. algorithm i.e. Intelligent, it uses threads i.e. Massively, it deciphers i.e. luminates the text and it solves super stuff therefore the title is completely justified. I give you my Massively Intelligent Non-Deterministic Luminating Effortless Super Solver (MINDLESS). If none of that interests you then please stick around and follow the side quest of looking for &lt;a href=&#34;http://justenoughcraig.blogspot.com/2014/01/just-say-no-to-passive-aggressive.html&#34;&gt;emotionally charged parenthesis&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Building an Interpreter</title>
      <link>https://quiescent.us/2012/05/building-an-interpreter/</link>
      <pubDate>Mon, 28 May 2012 17:03:55 +0000</pubDate>
      
      <guid>https://quiescent.us/2012/05/building-an-interpreter/</guid>
      <description>&lt;p&gt;When I started programming, I thought that compilers where these magic behemoths; Oracles which consumed your source code, and prophesied  the resulting program.  I thought that the compiler was an integral part of the &amp;ldquo;system&amp;rdquo;. I was excited to realize that the compiler is simply another program. A program you can write yourself. You can write a compiler, for your very own language.  Go ahead, make up a language, I&amp;rsquo;ll wait&amp;hellip;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.codestrokes.com/wp-content/uploads/2012/05/hourglass.gif&#34;&gt;&lt;img src=&#34;http://www.codestrokes.com/wp-content/uploads/2012/05/hourglass.gif&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Seriously though, making your own language is a very difficult task, and implementing a language useful enough for non-trivial problems is even more difficult. There is however, a very approachable goal here: Domain Specific Languages (DSLs).  DSLs are focused languages useful to a limited group of people for a limited purpose.&lt;/p&gt;
&lt;p&gt;I like to think of DSLs as tools. For example, sometimes one needs to automate a task, its might be easier to write a small program that helps with that task. But it might be even more useful to write a language that allows you to describe the problem better, then one can write a program using the new language to finish the task in an efficient and repeatable way.  The program has limited usefulness beyond its initial application, but for the application at hand, its perfect. SQL is the canonical example. In this post we&amp;rsquo;ll start with a basic grammar in EBNF. We&amp;rsquo;ll translate that to a flex lexer, and connect that to a bison parser. We&amp;rsquo;ll end up with a syntax tree which we&amp;rsquo;ll execute to calculate a result.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
