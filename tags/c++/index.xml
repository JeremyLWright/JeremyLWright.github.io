<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C&#43;&#43; on The Quiescent Current</title>
    <link>/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on The Quiescent Current</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>©2020 Jeremy Wright</copyright>
    <lastBuildDate>Sat, 03 Oct 2015 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>System languages should include Webapps</title>
      <link>/2015/10/system-languages-include-web/</link>
      <pubDate>Sat, 03 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>/2015/10/system-languages-include-web/</guid>
      <description>I was reading an FAQ today about some subtle C++ point and I came across a comment that explicitly excludes the beginning language-learner.
 By the way, it confuses most novice C++ programmers that private virtuals can be overridden&amp;hellip; However the private virtual approach is now common enough that confusion of novices is less of a concern.
 This left me frustrated that a language that has been core to my personal success so flippantly brushed aside its future user.</description>
      
    </item>
    
    <item>
      <title>Property Testing in C&#43;&#43;</title>
      <link>/2014/09/property-testing-in-c/</link>
      <pubDate>Wed, 03 Sep 2014 23:00:00 -0700</pubDate>
      
      <guid>/2014/09/property-testing-in-c/</guid>
      <description>&lt;!-- raw HTML omitted --&gt;</description>
      
    </item>
    
    <item>
      <title>Massively Intelligent Non-Deterministic Luminating Effortless Super Solver</title>
      <link>/2014/02/cracking-subciphercpp/</link>
      <pubDate>Wed, 12 Feb 2014 08:50:00 -0700</pubDate>
      
      <guid>/2014/02/cracking-subciphercpp/</guid>
      <description>&lt;p&gt;I worked the title of this article several times before I finally settled on the subtly epic heading you see above. Hopefully this title will funnel people off google into my blog (delicious SEO). I wanted to push the A.I. component of my solution because A.I. is awesome and mysterious, and cool (and can like solve jeopardy). I was quickly disillusioned however. Really, A.I. isn&amp;rsquo;t magic, rather it&amp;rsquo;s just the same thing computers have been doing for a long time: computing. Sadly this realization took several months in an A.I. class before I was sufficiently crestfallen. A.I. patterns including the hill climbing algorithm used here are indeed &amp;ldquo;intelligent&amp;rdquo; but really it a reflecting of the algorithm designer, not the entity executing the algorithm. So I built a substitution cipher solver in C++. It&amp;rsquo;s fast it uses random numbers i.e. non-deterministic, it uses an A.I. algorithm i.e. Intelligent, it uses threads i.e. Massively, it deciphers i.e. luminates the text and it solves super stuff therefore the title is completely justified. I give you my Massively Intelligent Non-Deterministic Luminating Effortless Super Solver (MINDLESS). If none of that interests you then please stick around and follow the side quest of looking for &lt;!-- raw HTML omitted --&gt;emotionally charged parenthesis&lt;!-- raw HTML omitted --&gt;.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Sean Parent: No Raw Loops</title>
      <link>/2013/11/sean-parent-no-raw-loops/</link>
      <pubDate>Sun, 24 Nov 2013 22:14:50 +0000</pubDate>
      
      <guid>/2013/11/sean-parent-no-raw-loops/</guid>
      <description>A group of colleagues and I watched Sean Parent&amp;rsquo;s Going Native Talk on &amp;ldquo;C++ Seasoning&amp;rdquo;. Parent takes some extreme views on how to use C++, but his examples for using the STL to simplify code are phenomenal. For a recent AI project I decided to apply Parent&amp;rsquo;s goal of &amp;ldquo;no raw loops&amp;rdquo;, I was blown away by the transformation&amp;hellip; err std::transformation this had on my code. In this post I indented to demonstrate several complex code blocks, or overly specific code blocks what were replaced by some STL magic.</description>
      
    </item>
    
    <item>
      <title>Is Monolithic Code Faster?</title>
      <link>/2013/07/is-monolithic-code-faster/</link>
      <pubDate>Sun, 14 Jul 2013 23:00:11 +0000</pubDate>
      
      <guid>/2013/07/is-monolithic-code-faster/</guid>
      <description>As a software engineer I have a vested interest in disproving this statement. Bjarne Stroustroup says C++ is designed to create efficient abstractions. A software engineer’s job is to create simple abstractions to complex systems. State machines form a large part of many systems. The other day, a co-worker came to me, and asked, “Is it better to make straight line code for each case statement, even if it repeats, or is it better to abstraction into functions and make the code ‘cleaner’.</description>
      
    </item>
    
    <item>
      <title>Building an Interpreter</title>
      <link>/2012/05/building-an-interpreter/</link>
      <pubDate>Mon, 28 May 2012 17:03:55 +0000</pubDate>
      
      <guid>/2012/05/building-an-interpreter/</guid>
      <description>When I started programming, I thought that compilers where these magic behemoths; Oracles which consumed your source code, and prophesied the resulting program. I thought that the compiler was an integral part of the &amp;ldquo;system&amp;rdquo;. I was excited to realize that the compiler is simply another program. A program you can write yourself. You can write a compiler, for your very own language. Go ahead, make up a language, I&amp;rsquo;ll wait&amp;hellip;</description>
      
    </item>
    
  </channel>
</rss>
