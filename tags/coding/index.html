<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.97.3" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>Coding&nbsp;&ndash;&nbsp;The Quiescent Current</title><link rel="stylesheet" href="/css/core.min.6794bc167e4ce0026d21831c61e605e88a70ef6cc11b090df06de3ed8be76f69afa57c9dcd7ba7210c777e124e943258.css" integrity="sha384-Z5S8Fn5M4AJtIYMcYeYF6Ipw72zBGwkN8G3j7Yvnb2mvpXydzXunIQx3fhJOlDJY"><link rel="alternate" type="application/rss+xml" href="/tags/coding/index.xml" title="The Quiescent Current" /><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Coding" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">The Quiescent Current</span></a></span>
        <span class="header right-side"></span></div><div class="site slogan"><span class="title">Go Far. Go Together.</span></div></section><section id="content"><section class="article header"><h1>Coding</h1></section><ul class="note list"><li class="item"><a class="note" href="/2015/10/system-languages-include-web/">
            <p class="note title">System languages should include Webapps</p><p class="note date">Saturday, October 3, 2015</p><p class="note content">I was reading an FAQ today about some subtle C++ point and I came across a comment that explicitly excludes the beginning language-learner.
 By the way, it confuses most novice C++ programmers that private virtuals can be overridden&hellip; However the private virtual approach is now common enough that confusion of novices is less of a concern.
 This left me frustrated that a language that has been core to my personal success so flippantly brushed aside its future user.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/coding/">Coding</a></p></li><li class="item"><a class="note" href="/2012/02/compile-time-polymorphism/">
            <p class="note title">Compile-Time Polymorphism</p><p class="note date">Sunday, February 5, 2012</p><p class="note content">Polymorphism is a tool in object orientation, which allows us to model behavior, while simultaneously leverage existing code. Polymorphism allows is behavior reuse. In C++ polymorphism, comes in 2 flavors, the standard runtime variant, and a curious compile time variant. Runtime polymorphism, like Java, leverages virtual functions to dynamically bind[1. With virtual functions the compiler doesn&rsquo;t know which method to call until runtime. In C++ this is implemented with the virtual method table ] a method at the call site. Compile Time polymorphism uses templates, to bind at compile time, thus negating the performance affect of virtual functions.
<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/coding/">Coding</a><a class="tag" href="/tags/idiom/">idiom</a><a class="tag" href="/tags/performance/">performance</a><a class="tag" href="/tags/template/">template</a><a class="tag" href="/tags/virtual/">virtual</a></p></li><li class="item"><a class="note" href="/2011/10/making-c-like-python-the-anderson-smart-pointer-pattern/">
            <p class="note title">Making C++ like Python: The Anderson Smart Pointer Pattern</p><p class="note date">Sunday, October 23, 2011</p><p class="note content">Choosing to use C++ brings the additional complexity of memory management. Dennis Ritchie once stated: The C Programming Language — A language which combines the flexibility of assembly language with the power of assembly language. C++ inherits much of that _flexibility, _however, this incidental complexity , can be relegated to a single class, leaving you with the high-level elegance of Python. RAII help with this additional complexity, however without a pattern for guidance implementing RAII consistently can be difficult, defeating the safety it provides.
<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/coding/">Coding</a><a class="tag" href="/tags/memory/">memory</a><a class="tag" href="/tags/python/">Python</a><a class="tag" href="/tags/raii/">RAII</a></p></li><li class="item"><a class="note" href="/2011/10/parallel-game-of-life/">
            <p class="note title">Parallel Game-of-Life</p><p class="note date">Sunday, October 23, 2011</p><p class="note content">Conway&rsquo;s Game of Life is a dramatic illustration of emmergent behavior; that a seemingly complex system, such as cell mitosis can be governed by a set of simple rules. OpenMP is a fantastic set of language extensions which allows one to add dramatic parallelism without complex thread management. As a demonstration of OpenMP &rsquo;s simplicity I implemented the Game of Life. The code and all analysis is available on bitbucket.org .
<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/coding/">Coding</a><a class="tag" href="/tags/parallel/">parallel</a></p></li><li class="item"><a class="note" href="/2011/09/the-1000000-compile/">
            <p class="note title">The $1,000,000 Compile</p><p class="note date">Thursday, September 22, 2011</p><p class="note content">Hitting the compile and run button costs $1,000,000. How would such a cost affect your test strategy? As extreme as that sounds, its a harsh reality for ASIC designers. The start-up costs for an ASIC design are extreme, as a result ASIC verification is very important. Especially since you can&rsquo;t just update a buggy ASIC. In software engineering, we design increasingly complex systems requiring more and more elegant test strategies. I propose ASIC verification is in a more mature state, and software engineers could learn a lot from the translation of these techniques.
<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/coding/">Coding</a><a class="tag" href="/tags/testing/">testing</a></p></li><li class="item"><a class="note" href="/2011/08/good-tools-excellent-results/">
            <p class="note title">Good Tools, Excellent Results</p><p class="note date">Sunday, August 21, 2011</p><p class="note content">This semester for the C++ practicum we are building a clone of Zork. Like many games of the genre, Zork is driven by a database. Our implementation is a JSON database. I chose JSON for a few reasons, but most importantly because its a human readable format that&rsquo;s simple to understand. I started by editing JSON files by hand in a text editor, however I found very quickly that investigating in a quick tool greatly improved my quality.
<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/coding/">Coding</a><a class="tag" href="/tags/productivity/">productivity</a><a class="tag" href="/tags/python/">Python</a><a class="tag" href="/tags/tools/">tools</a></p></li><li class="item"><a class="note" href="/2011/08/why-do-some-tutorials-use-stdcout-and-others-use-just-cout/">
            <p class="note title">Why do some tutorials use std::cout and others use just cout?</p><p class="note date">Friday, August 19, 2011</p></a><p class="note labels"><a class="tag" href="/tags/coding/">Coding</a><a class="tag" href="/tags/tutorial/">tutorial</a></p></li><li class="item"><a class="note" href="/2011/06/type-safe-variable-argument-lists/">
            <p class="note title">Type-Safe Variable Argument Lists</p><p class="note date">Monday, June 6, 2011</p><p class="note content">Type-safety is a popular topic. Perceived as a panacea for bad software, the Department of Defense implemented Ada. The original thought was restriction synonymous with robustness. From this, opponents claim type safe languages place the programmer’s hands in handcuffs, thereby thwarting generic code. Modern languages, such as D, and Java leverage a statically checked type system with a focus on consistency, not restriction. Modern type systems abet generic code, without sacrificing robustness. Today, there seems to be a general trend toward strong typing. Personally, I try to leverage the type system as a tool to ensure correct code.
D is a powerful language, that statically checks code correctness via a strong type system, yet still offers flexible constructs. D’s focus of code correctness, provides a strong type system, in a manner conducive to generic code. D’s type-safe variable argument list is an example of this.
<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/coding/">Coding</a><a class="tag" href="/tags/algorithm/">Algorithm</a><a class="tag" href="/tags/d/">D</a><a class="tag" href="/tags/type-safety/">Type Safety</a></p></li><li class="item"><a class="note" href="/2011/05/parallelism-in-d-bucket-sort-part-2/">
            <p class="note title">Parallelism in D</p><p class="note date">Sunday, May 29, 2011</p><p class="note content">Parallelism, it sounds like a religion, and in some sense it is. Like many facets of software engineering, writing good parallel code is more of an art than a science. I come from a FPGA background where parallelism is part of the language; part of the culture! The tools are designed to find deadlocks, analyze timing and the language itself is fully aware of parallelism. The hardware world understands parallelism, yet writing parallel software is still difficult. D is making some pioneering steps in the right direction for parallelism . I use a parallel implementation of bucket sort to show how D makes writing parallel code, correct.
<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/d/">D</a><a class="tag" href="/tags/coding/">Coding</a><a class="tag" href="/tags/algorithm/">algorithm</a><a class="tag" href="/tags/parallel/">parallel</a><a class="tag" href="/tags/real-time/">real-time</a><a class="tag" href="/tags/realtime/">realtime</a><a class="tag" href="/tags/sorting/">Sorting</a></p></li><li class="item"><a class="note" href="/2011/05/bucket-sort/">
            <p class="note title">Bucket Sort</p><p class="note date">Tuesday, May 24, 2011</p><p class="note content">D Source Code Sorting is a very important operation in computer programs. Knuth devotes an entire chapter to sorting and search. Sorting algorithms, like most algorithms, use the Big O notation to compare computational complexity . Bucket sort is one such sorting algorithm. however bucket sort typically doesn’t actually sort the array. In the normal case, bucket sort is used to partition the data set into groups, or buckets. Each bucket is then sorted using a separate algorithm such as quicksort, or insertion sort.
<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/coding/">Coding</a><a class="tag" href="/tags/d/">D</a><a class="tag" href="/tags/sorting/">Sorting</a></p></li></ul><div class="pagination">
    <ul><li><a class="active" href="/tags/coding/">1</a></li><li><a class="" href="/tags/coding/page/2/">2</a></li></ul>
</div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">©2022 Jeremy Wright</p>
    <p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div>
</section><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/&#43;DiW/UqRcLbRjq" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l&#43;B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd&#43;qj&#43;o24G5ZU2zJz" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
            onload="renderMathInElement(document.body);"></script></body>

</html>