<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Coding on The Quiescent Current</title>
    <link>https://quiescent.us/tags/coding/</link>
    <description>Recent content in Coding on The Quiescent Current</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>©2022 Jeremy Wright</copyright>
    <lastBuildDate>Sat, 03 Oct 2015 00:00:00 +0000</lastBuildDate><atom:link href="https://quiescent.us/tags/coding/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>System languages should include Webapps</title>
      <link>https://quiescent.us/2015/10/system-languages-include-web/</link>
      <pubDate>Sat, 03 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://quiescent.us/2015/10/system-languages-include-web/</guid>
      <description>I was reading an FAQ today about some subtle C++ point and I came across a comment that explicitly excludes the beginning language-learner.
By the way, it confuses most novice C++ programmers that private virtuals can be overridden&amp;hellip; However the private virtual approach is now common enough that confusion of novices is less of a concern.
This left me frustrated that a language that has been core to my personal success so flippantly brushed aside its future user.</description>
    </item>
    
    <item>
      <title>Compile-Time Polymorphism</title>
      <link>https://quiescent.us/2012/02/compile-time-polymorphism/</link>
      <pubDate>Sun, 05 Feb 2012 21:14:29 +0000</pubDate>
      
      <guid>https://quiescent.us/2012/02/compile-time-polymorphism/</guid>
      <description>&lt;p&gt;Polymorphism is a tool in object orientation, which allows us to model behavior, while simultaneously leverage existing code. Polymorphism allows is behavior reuse.  In C++ polymorphism, comes in 2 flavors, the standard runtime variant, and a curious compile time variant.  Runtime polymorphism, like Java, leverages virtual functions to dynamically bind[1. With virtual functions the compiler doesn&amp;rsquo;t know which method to call until runtime. In C++ this is implemented with the &lt;a href=&#34;http://en.wikipedia.org/wiki/Virtual_method_table&#34;&gt;virtual method table&lt;/a&gt;] a method at the call site. Compile Time polymorphism uses templates, to bind at compile time, thus negating the performance affect of virtual functions.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Making C&#43;&#43; like Python: The Anderson Smart Pointer Pattern</title>
      <link>https://quiescent.us/2011/10/making-c-like-python-the-anderson-smart-pointer-pattern/</link>
      <pubDate>Sun, 23 Oct 2011 19:00:21 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/10/making-c-like-python-the-anderson-smart-pointer-pattern/</guid>
      <description>&lt;p&gt;Choosing to use C++ brings the additional complexity of memory management.  Dennis Ritchie once stated: The C Programming Language — A language which combines the flexibility of assembly language with the power of assembly language. C++ inherits much of that _flexibility, _however, this &lt;a href=&#34;http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey&#34;&gt;incidental complexity&lt;/a&gt;, can be relegated to a single class, leaving you with the high-level elegance of Python. RAII help with this additional complexity, however without a pattern for guidance implementing RAII consistently can be difficult, defeating the safety it provides.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Parallel Game-of-Life</title>
      <link>https://quiescent.us/2011/10/parallel-game-of-life/</link>
      <pubDate>Sun, 23 Oct 2011 17:55:47 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/10/parallel-game-of-life/</guid>
      <description>&lt;p&gt;Conway&amp;rsquo;s &lt;a href=&#34;http://www.bitstorm.org/gameoflife/&#34;&gt;Game of Life&lt;/a&gt; is a dramatic illustration of emmergent behavior; that a seemingly complex system, such as cell mitosis can be governed by a set of simple rules. OpenMP is a fantastic set of language extensions which allows one to add dramatic parallelism without complex thread management.  As a demonstration of &lt;a href=&#34;http://openmp.org/wp/&#34;&gt;OpenMP&lt;/a&gt;&amp;rsquo;s simplicity I implemented the Game of Life. The code and all analysis is available on &lt;a href=&#34;https://bitbucket.org/jwright/parallel-game-of-life&#34;&gt;bitbucket.org&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>The $1,000,000 Compile</title>
      <link>https://quiescent.us/2011/09/the-1000000-compile/</link>
      <pubDate>Thu, 22 Sep 2011 22:40:42 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/09/the-1000000-compile/</guid>
      <description>&lt;p&gt;Hitting the compile and run button costs $1,000,000. How would such a cost affect your test strategy? As extreme as that sounds, its a harsh reality for ASIC designers. The start-up costs for an ASIC design are extreme, as a result ASIC verification is very important. Especially since you can&amp;rsquo;t just update a buggy ASIC.  In software engineering, we design increasingly complex systems requiring more and more elegant test strategies.  I propose ASIC verification is in a more mature state, and software engineers could learn a lot from the translation of these techniques.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Good Tools, Excellent Results</title>
      <link>https://quiescent.us/2011/08/good-tools-excellent-results/</link>
      <pubDate>Sun, 21 Aug 2011 07:23:25 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/08/good-tools-excellent-results/</guid>
      <description>&lt;p&gt;This semester for the C++ practicum we are building a clone of Zork.  Like many games of the genre, Zork is driven by a database.  Our implementation is a JSON database.  I chose JSON for a few reasons, but most importantly because its a human readable format that&amp;rsquo;s simple to understand.  I started by editing JSON files by hand in a text editor, however I found very quickly that investigating in a quick tool greatly improved my quality.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Why do some tutorials use std::cout and others use just cout?</title>
      <link>https://quiescent.us/2011/08/why-do-some-tutorials-use-stdcout-and-others-use-just-cout/</link>
      <pubDate>Fri, 19 Aug 2011 16:55:56 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/08/why-do-some-tutorials-use-stdcout-and-others-use-just-cout/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Type-Safe Variable Argument Lists</title>
      <link>https://quiescent.us/2011/06/type-safe-variable-argument-lists/</link>
      <pubDate>Mon, 06 Jun 2011 06:59:00 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/06/type-safe-variable-argument-lists/</guid>
      <description>&lt;p&gt;Type-safety is a popular topic. Perceived as a panacea for bad software, the Department of Defense implemented Ada.  The original thought was restriction synonymous with robustness. From this, opponents claim type safe languages place the programmer’s hands in handcuffs, thereby thwarting generic code. Modern languages, such as D, and Java leverage a statically checked type system with a focus on consistency, not restriction.  Modern type systems abet generic code, without sacrificing robustness.  Today, there seems to be a general trend toward strong typing.  Personally, I try to leverage the type system as a tool to ensure correct code.&lt;/p&gt;
&lt;blockquote&gt;D is a powerful  language, that statically checks code correctness via a strong type system, yet still offers flexible constructs.&lt;/blockquote&gt;
&lt;p&gt;D’s focus of code correctness, provides a strong type system, in a manner conducive to generic code.  D’s type-safe variable argument list is an example of this.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Parallelism in D</title>
      <link>https://quiescent.us/2011/05/parallelism-in-d-bucket-sort-part-2/</link>
      <pubDate>Sun, 29 May 2011 18:02:24 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/05/parallelism-in-d-bucket-sort-part-2/</guid>
      <description>&lt;p&gt;Parallelism, it sounds like a religion, and in some sense it is. Like many facets of software engineering, writing good parallel code is more of an art than a science.  I come from a FPGA background where parallelism is part of the language; part of the culture! The tools are designed to find deadlocks, analyze timing and the language itself is fully aware of parallelism.  The hardware world understands parallelism, yet writing parallel software is still difficult.  D is making some pioneering steps in the right direction for &lt;a href=&#34;http://www.digitalmars.com/d/2.0/phobos/std_parallelism.html&#34;&gt;parallelism&lt;/a&gt;.  I use a parallel implementation of bucket sort to show how D makes writing parallel code, correct.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Bucket Sort</title>
      <link>https://quiescent.us/2011/05/bucket-sort/</link>
      <pubDate>Tue, 24 May 2011 04:59:59 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/05/bucket-sort/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://bitbucket.org/jwright/bucket-sort/overview&#34;&gt;D Source Code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Sorting is a very important operation in computer programs. Knuth devotes an entire chapter to sorting and search. Sorting algorithms, like most algorithms, use the &lt;a href=&#34;http://en.wikipedia.org/wiki/Big_Oh_notation&#34;&gt;Big O notation&lt;/a&gt; to compare &lt;a href=&#34;http://en.wikipedia.org/wiki/Computational_complexity_theory&#34;&gt;computational complexity&lt;/a&gt;.  &lt;a href=&#34;http://en.wikipedia.org/wiki/Bucket_sort&#34;&gt;Bucket sort&lt;/a&gt; is one such sorting algorithm.  however bucket sort typically doesn’t actually sort the array.  In the normal case, bucket sort is used to partition the data set into groups, or buckets.  Each bucket is then sorted using a separate algorithm such as quicksort, or insertion sort.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Thing a Week: Algorithm Edition</title>
      <link>https://quiescent.us/2011/05/thing-a-week-algorithm-edition/</link>
      <pubDate>Tue, 03 May 2011 23:37:37 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/05/thing-a-week-algorithm-edition/</guid>
      <description>In homage to Jonathan Coulton, this summer I intend to explore a series of algorithms in an effort to both learn the D programming language, as well as deepen my computer science background. First up, the Red-Black Tree.</description>
    </item>
    
  </channel>
</rss>
