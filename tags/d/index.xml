<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>D on Code Strokes</title>
    <link>https://quiescent.us/tags/d/</link>
    <description>Recent content in D on Code Strokes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 03 Oct 2015 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://quiescent.us/tags/d/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>System languages should include Webapps</title>
      <link>https://quiescent.us/2015/10/system-languages-include-web/</link>
      <pubDate>Sat, 03 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://quiescent.us/2015/10/system-languages-include-web/</guid>
      <description>I was reading an FAQ today about some subtle C++ point and I came across a comment that explicitly excludes the beginning language-learner.
 By the way, it confuses most novice C++ programmers that private virtuals can be overridden&amp;hellip; However the private virtual approach is now common enough that confusion of novices is less of a concern.
 This left me frustrated that a language that has been core to my personal success so flippantly brushed aside its future user.</description>
    </item>
    
    <item>
      <title>Making C&#43;&#43; like Python: The Anderson Smart Pointer Pattern</title>
      <link>https://quiescent.us/2011/10/making-c-like-python-the-anderson-smart-pointer-pattern/</link>
      <pubDate>Sun, 23 Oct 2011 19:00:21 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/10/making-c-like-python-the-anderson-smart-pointer-pattern/</guid>
      <description>Choosing to use C++ brings the additional complexity of memory management. Dennis Ritchie once stated: The C Programming Language — A language which combines the flexibility of assembly language with the power of assembly language. C++ inherits much of that _flexibility, _however, this incidental complexity, can be relegated to a single class, leaving you with the high-level elegance of Python. RAII help with this additional complexity, however without a pattern for guidance implementing RAII consistently can be difficult, defeating the safety it provides.</description>
    </item>
    
    <item>
      <title>Type-Safe Variable Argument Lists</title>
      <link>https://quiescent.us/2011/06/type-safe-variable-argument-lists/</link>
      <pubDate>Mon, 06 Jun 2011 06:59:00 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/06/type-safe-variable-argument-lists/</guid>
      <description>Type-safety is a popular topic. Perceived as a panacea for bad software, the Department of Defense implemented Ada. The original thought was restriction synonymous with robustness. From this, opponents claim type safe languages place the programmer’s hands in handcuffs, thereby thwarting generic code. Modern languages, such as D, and Java leverage a statically checked type system with a focus on consistency, not restriction. Modern type systems abet generic code, without sacrificing robustness.</description>
    </item>
    
    <item>
      <title>Parallelism in D</title>
      <link>https://quiescent.us/2011/05/parallelism-in-d-bucket-sort-part-2/</link>
      <pubDate>Sun, 29 May 2011 18:02:24 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/05/parallelism-in-d-bucket-sort-part-2/</guid>
      <description>Parallelism, it sounds like a religion, and in some sense it is. Like many facets of software engineering, writing good parallel code is more of an art than a science. I come from a FPGA background where parallelism is part of the language; part of the culture! The tools are designed to find deadlocks, analyze timing and the language itself is fully aware of parallelism. The hardware world understands parallelism, yet writing parallel software is still difficult.</description>
    </item>
    
    <item>
      <title>Bucket Sort</title>
      <link>https://quiescent.us/2011/05/bucket-sort/</link>
      <pubDate>Tue, 24 May 2011 04:59:59 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/05/bucket-sort/</guid>
      <description>D Source Code
Sorting is a very important operation in computer programs. Knuth devotes an entire chapter to sorting and search. Sorting algorithms, like most algorithms, use the Big O notation to compare computational complexity. Bucket sort is one such sorting algorithm. however bucket sort typically doesn’t actually sort the array. In the normal case, bucket sort is used to partition the data set into groups, or buckets. Each bucket is then sorted using a separate algorithm such as quicksort, or insertion sort.</description>
    </item>
    
    <item>
      <title>D for the C&#43;&#43; Programmer</title>
      <link>https://quiescent.us/2011/05/d-for-the-c-programmer-red-black-tree-part-3/</link>
      <pubDate>Wed, 18 May 2011 03:06:36 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/05/d-for-the-c-programmer-red-black-tree-part-3/</guid>
      <description>As a comparative study, I am porting a Red-Black Tree from C++ to the D programming language (Part 1, Part 2). Overall D is an easy, practical transition for the C++ programmer. D provides a number of features for implementing correct code, however it is D’s simplicity that makes it truly enticing as a replacement. While D retains _C Style Syntax, _it is considerably simpler than C++, especially in the presence of exceptions.</description>
    </item>
    
    <item>
      <title>Class Invariants</title>
      <link>https://quiescent.us/2011/05/class-invariants-red-black-tree-part-2/</link>
      <pubDate>Fri, 13 May 2011 02:40:48 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/05/class-invariants-red-black-tree-part-2/</guid>
      <description>This week, I started porting my C++ implementation of the Red-Black tree to D. I am trying to pay special attention to the features of D, intended to make writing correct code easier. While on that vane, I was reading an excellent article, discussing invariants, and I was pleased to find such a useful implementation of the class invariant in the D language.
Invariants come from the same “design-by-contract” idiom, famous for pre- and post- conditions.</description>
    </item>
    
    <item>
      <title>The Red-Black Tree</title>
      <link>https://quiescent.us/2011/05/the-red-black-tree-part-1/</link>
      <pubDate>Mon, 09 May 2011 06:59:01 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/05/the-red-black-tree-part-1/</guid>
      <description>C++ Source Code D Source Code
D provides a number of features that simplify designing software, especially in the embedded environment. I will show in this 2 part comparison, between C++ and D, that D helps one write correct code. Correct code is something Andrei Alexandrescu, stresses heavily as a prominent feature of D. I use the Red-Black Tree for such a comparison since its complicated enough to make memory management difficult, while retaining real-world application.</description>
    </item>
    
  </channel>
</rss>