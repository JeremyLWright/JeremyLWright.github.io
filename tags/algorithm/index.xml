<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on The Quiescent Current</title>
    <link>https://quiescent.us/tags/algorithm/</link>
    <description>Recent content in Algorithm on The Quiescent Current</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>©2022 Jeremy Wright</copyright>
    <lastBuildDate>Sun, 07 Jul 2013 23:00:30 +0000</lastBuildDate><atom:link href="https://quiescent.us/tags/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Patterns are evidence of a language&#39;s lacking</title>
      <link>https://quiescent.us/2013/07/patterns-are-evidence-of-a-languages-lacking/</link>
      <pubDate>Sun, 07 Jul 2013 23:00:30 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/07/patterns-are-evidence-of-a-languages-lacking/</guid>
      <description>&lt;p&gt;A coworker of mine stated something interesting, &amp;ldquo;&amp;hellip;a pattern is evidence of missing feature in the language&amp;hellip;&amp;rdquo;. At first I struggled with this statement. How can you design a language general enough to be widely used, and simultaneously cover all the desirable idioms such that patterns are built in? At first this seemed silly to me, until I heard Erik Meijer state in a Haskell lecture, &amp;ldquo;..this is why we implemented LINQ as a pattern instead of a language feature&amp;hellip;&amp;rdquo;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Type-Safe Variable Argument Lists</title>
      <link>https://quiescent.us/2011/06/type-safe-variable-argument-lists/</link>
      <pubDate>Mon, 06 Jun 2011 06:59:00 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/06/type-safe-variable-argument-lists/</guid>
      <description>&lt;p&gt;Type-safety is a popular topic. Perceived as a panacea for bad software, the Department of Defense implemented Ada.  The original thought was restriction synonymous with robustness. From this, opponents claim type safe languages place the programmer’s hands in handcuffs, thereby thwarting generic code. Modern languages, such as D, and Java leverage a statically checked type system with a focus on consistency, not restriction.  Modern type systems abet generic code, without sacrificing robustness.  Today, there seems to be a general trend toward strong typing.  Personally, I try to leverage the type system as a tool to ensure correct code.&lt;/p&gt;
&lt;blockquote&gt;D is a powerful  language, that statically checks code correctness via a strong type system, yet still offers flexible constructs.&lt;/blockquote&gt;
&lt;p&gt;D’s focus of code correctness, provides a strong type system, in a manner conducive to generic code.  D’s type-safe variable argument list is an example of this.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Parallelism in D</title>
      <link>https://quiescent.us/2011/05/parallelism-in-d-bucket-sort-part-2/</link>
      <pubDate>Sun, 29 May 2011 18:02:24 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/05/parallelism-in-d-bucket-sort-part-2/</guid>
      <description>&lt;p&gt;Parallelism, it sounds like a religion, and in some sense it is. Like many facets of software engineering, writing good parallel code is more of an art than a science.  I come from a FPGA background where parallelism is part of the language; part of the culture! The tools are designed to find deadlocks, analyze timing and the language itself is fully aware of parallelism.  The hardware world understands parallelism, yet writing parallel software is still difficult.  D is making some pioneering steps in the right direction for &lt;a href=&#34;http://www.digitalmars.com/d/2.0/phobos/std_parallelism.html&#34;&gt;parallelism&lt;/a&gt;.  I use a parallel implementation of bucket sort to show how D makes writing parallel code, correct.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>D for the C&#43;&#43; Programmer</title>
      <link>https://quiescent.us/2011/05/d-for-the-c-programmer-red-black-tree-part-3/</link>
      <pubDate>Wed, 18 May 2011 03:06:36 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/05/d-for-the-c-programmer-red-black-tree-part-3/</guid>
      <description>&lt;p&gt;As a comparative study, I am porting a Red-Black Tree from C++ to the &lt;a href=&#34;http://www.digitalmars.com/d/2.0/dmd-linux.html&#34;&gt;D programming language&lt;/a&gt; (&lt;a href=&#34;http://www.codestrokes.com/archives/59&#34;&gt;Part 1&lt;/a&gt;, &lt;a href=&#34;http://www.codestrokes.com/archives/83&#34;&gt;Part 2&lt;/a&gt;). Overall D is an easy, practical transition for the C++ programmer. D provides a number of features for implementing correct code, however it is D’s simplicity that makes it truly enticing as a replacement. While D retains _C Style Syntax, _it is considerably simpler than C++, especially in the presence of exceptions.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Class Invariants</title>
      <link>https://quiescent.us/2011/05/class-invariants-red-black-tree-part-2/</link>
      <pubDate>Fri, 13 May 2011 02:40:48 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/05/class-invariants-red-black-tree-part-2/</guid>
      <description>&lt;p&gt;This week, I started porting my &lt;a href=&#34;http://www.codestrokes.com/archives/59&#34;&gt;C++ implementation&lt;/a&gt; of the Red-Black tree to D.  I am trying to pay special attention to the features of D, intended to make writing correct code easier. While on that vane,  I was reading an excellent &lt;a href=&#34;http://reprog.wordpress.com/2010/04/25/writing-correct-code-part-1-invariants-binary-search-part-4a/&#34;&gt;article&lt;/a&gt;, discussing invariants, and I was pleased to find such a useful implementation of the &lt;a href=&#34;http://www.digitalmars.com/d/2.0/class.html#Invariant&#34;&gt;class invariant&lt;/a&gt; in the D language.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>The Red-Black Tree</title>
      <link>https://quiescent.us/2011/05/the-red-black-tree-part-1/</link>
      <pubDate>Mon, 09 May 2011 06:59:01 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/05/the-red-black-tree-part-1/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://bitbucket.org/jwright/cse310-red-black-tree/overview&#34;&gt;C++ Source Code&lt;/a&gt;
&lt;a href=&#34;https://bitbucket.org/jwright/red-black-tree-d&#34;&gt;D Source Code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;D provides a number of features that simplify designing software, especially in the embedded environment.  I will show in this 2 part comparison, between C++ and D, that D helps one write &lt;strong&gt;correct code&lt;/strong&gt;.  Correct code is something &lt;a href=&#34;http://erdani.com/&#34;&gt;Andrei Alexandrescu&lt;/a&gt;, stresses heavily as a prominent feature of D.   I use the Red-Black Tree for such a comparison since its complicated enough to make memory management difficult, while retaining real-world application.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
