<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Haskell on QE</title>
    <link>https://quiescent.us/tags/haskell/</link>
    <description>Recent content in Haskell on QE</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 20 Oct 2013 23:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://quiescent.us/tags/haskell/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Idiomatic Learning</title>
      <link>https://quiescent.us/2013/10/idiomatic-learning/</link>
      <pubDate>Sun, 20 Oct 2013 23:00:00 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/10/idiomatic-learning/</guid>
      <description>When learning a new language I find it helpful to study a languages idioms. Idioms exist in a language for a specific reason. Sometimes that reason is to further the principles of the language, other times it’s to mask, or otherwise deal with some underlying design decision of the language. Currently, I am studying Haskell, and currently I am struggle to clarify the idioms of the language. The syntax is still very new and awkward, currently with a total authoring in Haskell of 713 lines.</description>
    </item>
    
    <item>
      <title>Interesting article about Monads</title>
      <link>https://quiescent.us/2013/08/interesting-article-about-monads/</link>
      <pubDate>Fri, 02 Aug 2013 22:49:01 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/08/interesting-article-about-monads/</guid>
      <description>I found an interesting blog today with some clear and interesting discussion on Haskell, and Monads: http://intoverflow.wordpress.com/2010/07/20/i-come-from-java-and-want-to-know-what-monads-are-in-haskell/</description>
    </item>
    
    <item>
      <title>My Haskell Environment for Project Euler</title>
      <link>https://quiescent.us/2013/08/my-haskell-environment-for-project-euler/</link>
      <pubDate>Fri, 02 Aug 2013 16:51:40 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/08/my-haskell-environment-for-project-euler/</guid>
      <description>For the last several months I&amp;rsquo;ve been working on Project Euler in Haskell. My intent has been to learn Haskell, and grasp the functional concepts. While working on several problems it&amp;rsquo;s important to have a workflow that allows for a fast cycle time. I spent some time with Cabal, attempting to build a scheme that works efficiently, but was unable to do so. Instead I setup a mix of cabal-dev, and make to build a fast workflow that allow for compiling, testing, common code libraries, and benchmarks.</description>
    </item>
    
    <item>
      <title>Haskell a Few Problems Later</title>
      <link>https://quiescent.us/2013/05/haskell-a-few-problems-later/</link>
      <pubDate>Tue, 14 May 2013 04:28:58 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/05/haskell-a-few-problems-later/</guid>
      <description>Well, the Haskell honeymoon is over for me. I spent some time working on a few Project Euler problems this weekend, and my initial assumptions formed from toy problems were dashed. While I was able to solve 3 problems fairly quickly, I faced a number of non trivial bugs, and memory issues. On the other side of my naïve passion, I’m finding a functional thought process, and it’s exciting.
My problems were really centered around a naïve belief that Haskell could convert my inefficient algorithms to some &amp;ldquo;mathematically pure&amp;rdquo; representation.</description>
    </item>
    
    <item>
      <title>Haskell Day 1 (Again)</title>
      <link>https://quiescent.us/2013/04/haskell-day-1-again/</link>
      <pubDate>Mon, 22 Apr 2013 05:29:11 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/04/haskell-day-1-again/</guid>
      <description>I&amp;rsquo;ve restarted my haskell programming education. Here is my implementation of FizzBuzz
fizzbuzz x | x `mod` 15 == 0 = &amp;quot;FIZZBUZZ&amp;quot; | x `mod` 3 == 0 = &amp;quot;FIZZ&amp;quot; | x `mod` 5 == 0 = &amp;quot;BUZZ&amp;quot; | otherwise = show x main = print (map fizzbuzz [1..100])  [suffusion-adsense client=&#39;ca-pub-6284398857369558&amp;rsquo; slot=&#39;1495369305&amp;rsquo; width=&#39;728&amp;rsquo; height=&#39;90&amp;rsquo;]</description>
    </item>
    
    <item>
      <title>Know Its Name</title>
      <link>https://quiescent.us/2012/07/know-its-name/</link>
      <pubDate>Sat, 21 Jul 2012 19:24:19 +0000</pubDate>
      
      <guid>https://quiescent.us/2012/07/know-its-name/</guid>
      <description>Programming is at it&amp;rsquo;s heart an struggle in communication. Source code is the communication medium with the processor; Comment the medium to other coders, and UML the medium to higher-level communication. Computer Scientists have the stereotype of being poor communicators, but in our own mediums, we&amp;rsquo;re phenomenal. This fact is no where more apparent, than trying to explain source code to someone else. How does one read source code? I&amp;rsquo;m currently, learning Haskell, and my first goal is to understand this question.</description>
    </item>
    
  </channel>
</rss>