<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.88.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>The Quiescent Current&nbsp;&ndash;&nbsp;Go Far. Go Together.</title><link rel="stylesheet" href="/css/core.min.6794bc167e4ce0026d21831c61e605e88a70ef6cc11b090df06de3ed8be76f69afa57c9dcd7ba7210c777e124e943258.css" integrity="sha384-Z5S8Fn5M4AJtIYMcYeYF6Ipw72zBGwkN8G3j7Yvnb2mvpXydzXunIQx3fhJOlDJY"><link rel="alternate" type="application/rss+xml" href="/index.xml" title="The Quiescent Current" /><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="The Quiescent Current" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">The Quiescent Current</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="/posts">Blog</a><a class="nav item" href="/series">Series</a><a class="nav item" href="/languages">Languages</a><a class="nav item" href="/about">About</a></nav></div></span></div><div class="site slogan"><span class="title">Go Far. Go Together.</span></div></section><section id="content"><ul class="note list"><li class="item"><a class="note" href="/2012/08/the-turbulent-history-of-managed-code/">
            <p class="note title">The Turbulent History of Managed Code</p><p class="note date">Tuesday, August 28, 2012</p><p class="note content">Managed Code is a fascinating technology; Just-In-Time compilation provides advanced run-time optimization and strong type safety can render the hardware MMU obsolete . However the managed code renaissance is again in decline, and interestingly more than technology, business is changing the managed/native landscape. More than any other other metric, managed code is about maximizing programmer productivity.
In 1977, Infocom released Zork. Zork was an innovative game. Its sophisticated linguistics made for an immersive experience for its adventurers.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/productivity/">Productivity</a><a class="tag" href="/tags/java/">Java</a><a class="tag" href="/tags/managed-code/">Managed Code</a></p></li><li class="item"><a class="note" href="/2012/07/know-its-name/">
            <p class="note title">Know Its Name</p><p class="note date">Saturday, July 21, 2012</p><p class="note content">Programming is at it&rsquo;s heart an struggle in communication. Source code is the communication medium with the processor; Comment the medium to other coders, and UML the medium to higher-level communication. Computer Scientists have the stereotype of being poor communicators, but in our own mediums, we&rsquo;re phenomenal. This fact is no where more apparent, than trying to explain source code to someone else. How does one read source code? I&rsquo;m currently, learning Haskell, and my first goal is to understand this question.<span class="mldr">&mldr;</span></p></a></li><li class="item"><a class="note" href="/2012/07/the-importance-of-system-design/">
            <p class="note title">The Importance of System Design</p><p class="note date">Sunday, July 15, 2012</p><p class="note content">For the small programs we tend to implement as part of a semester project, or the simple &ldquo;one-off/get-it-done&rdquo; programs at work, system design rarely plays a part. However, even in the smallest problems a top-level system design is critical for consistency and ease of use. Class components, regardless of how precise and accurate they are in their own internal design, if they aren&rsquo;t externally consistent with other objects, the system will be brittle, and difficult to use.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/design/">Design</a><a class="tag" href="/tags/bottom-up/">bottom-up</a><a class="tag" href="/tags/top-down/">top-down</a></p></li><li class="item"><a class="note" href="/2012/05/building-an-interpreter/">
            <p class="note title">Building an Interpreter</p><p class="note date">Monday, May 28, 2012</p><p class="note content">When I started programming, I thought that compilers where these magic behemoths; Oracles which consumed your source code, and prophesied the resulting program. I thought that the compiler was an integral part of the &ldquo;system&rdquo;. I was excited to realize that the compiler is simply another program. A program you can write yourself. You can write a compiler, for your very own language. Go ahead, make up a language, I&rsquo;ll wait&hellip;<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/compilation/">Compilation</a><a class="tag" href="/tags/ast/">AST</a><a class="tag" href="/tags/bison/">Bison</a><a class="tag" href="/tags/c&#43;&#43;/">C&#43;&#43;</a><a class="tag" href="/tags/compiler/">compiler</a><a class="tag" href="/tags/flex/">Flex</a></p></li><li class="item"><a class="note" href="/2012/03/multicast-delegates-in-c11/">
            <p class="note title">Multicast Delegates in C++11</p><p class="note date">Sunday, March 25, 2012</p><p class="note content">C# has a wonderfully flexible delegate system capable of multicast events. This simple tool makes event driven software easier to write, and reduces coupling between objects. In 2003 Herb Sutter implemented a general form of the Observer pattern [1]. He called this the multi_function. It uses a mixture of TR1 and boost components to build a multi-cast delegate similar to C#&rsquo;s. Fast-forward 9 years, and we now have variadic-templates thanks to C++11.<span class="mldr">&mldr;</span></p></a></li><li class="item"><a class="note" href="/2012/03/abstract-syntax-trees-introduction-to-flex/">
            <p class="note title">Abstract Syntax Trees: Introduction to Flex</p><p class="note date">Sunday, March 18, 2012</p><p class="note content">Bison is an incredibly powerful parser generator tool. However most of the examples, and tutorials demonstrate Bison&rsquo;s parsing ability, using on-the-fly computation instead of building a Syntax Tree. Bison is fully capable to generate the front-end of a simple compiler, but to do so, we have to build a syntax tree. Come to find out, building a syntax tree with Bison isn&rsquo;t that difficult, and the key is how one leverages the semantic actions.<span class="mldr">&mldr;</span></p></a></li><li class="item"><a class="note" href="/2012/02/branching-with-mercurial/">
            <p class="note title">Branching with Mercurial</p><p class="note date">Monday, February 20, 2012</p><p class="note content">Mercurial supports two separate methods for branching. The first is built into how distributed version control functions, in that every clone is a branch itself. This is the branching method Joel Sposky recommends on hginit.com. The second method is called local branches . Initially I liked the local branch method; I liked it for the fact that I felt smart for using it. It did not improve productivity. There is a simple reason for this, with local branches it is difficult to diff the branch to the main branch of development e.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/project/">Project</a></p></li><li class="item"><a class="note" href="/2012/02/compile-time-polymorphism/">
            <p class="note title">Compile-Time Polymorphism</p><p class="note date">Sunday, February 5, 2012</p><p class="note content">Polymorphism is a tool in object orientation, which allows us to model behavior, while simultaneously leverage existing code. Polymorphism allows is behavior reuse. In C++ polymorphism, comes in 2 flavors, the standard runtime variant, and a curious compile time variant. Runtime polymorphism, like Java, leverages virtual functions to dynamically bind[1. With virtual functions the compiler doesn&rsquo;t know which method to call until runtime. In C++ this is implemented with the virtual method table ] a method at the call site.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/coding/">Coding</a><a class="tag" href="/tags/idiom/">idiom</a><a class="tag" href="/tags/performance/">performance</a><a class="tag" href="/tags/template/">template</a><a class="tag" href="/tags/virtual/">virtual</a></p></li><li class="item"><a class="note" href="/2011/11/parallel-binary-buddy-the-friendly-memory-manager/">
            <p class="note title">Parallel Binary Buddy: The Friendly Memory Manager</p><p class="note date">Wednesday, November 23, 2011</p><p class="note content">Fragmentation, the allocator&rsquo;s sin. Each byte A buddy, A friend
 Introduction
Memory management is pervasive in all forms of software, not just operating systems. Embedded Systems, when dynamic memory is acceptable, tend to use memory pools to the heap. Standard desktop applications use the platform&rsquo;s std::new or malloc. However, when a system is more complex, a memory manager may be used. Memory managers allow the programmer to strictly control application memory, in a way that flows with the rest of the system&rsquo;s design.<span class="mldr">&mldr;</span></p></a></li><li class="item"><a class="note" href="/2011/10/making-c-like-python-the-anderson-smart-pointer-pattern/">
            <p class="note title">Making C++ like Python: The Anderson Smart Pointer Pattern</p><p class="note date">Sunday, October 23, 2011</p><p class="note content">Choosing to use C++ brings the additional complexity of memory management. Dennis Ritchie once stated: The C Programming Language — A language which combines the flexibility of assembly language with the power of assembly language. C++ inherits much of that _flexibility, _however, this incidental complexity , can be relegated to a single class, leaving you with the high-level elegance of Python. RAII help with this additional complexity, however without a pattern for guidance implementing RAII consistently can be difficult, defeating the safety it provides.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/coding/">Coding</a><a class="tag" href="/tags/memory/">memory</a><a class="tag" href="/tags/python/">Python</a><a class="tag" href="/tags/raii/">RAII</a></p></li></ul><div class="pagination">
    <ul><li><a class="" href="/">1</a></li><li><a class="" href="/page/2/">2</a></li><li><a class="" href="/page/3/">3</a></li><li><a class="" href="/page/4/">4</a></li><li><a class="active" href="/page/5/">5</a></li><li><a href="/page/6/"><span class="iconfont icon-pagenext"></span></a></li></ul>
</div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">©2021 Jeremy Wright</p>
    <p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div>
</section><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/&#43;DiW/UqRcLbRjq" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l&#43;B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd&#43;qj&#43;o24G5ZU2zJz" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
            onload="renderMathInElement(document.body);"></script></body>

</html>