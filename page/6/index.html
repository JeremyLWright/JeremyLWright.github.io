<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.79.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>Quiescent Engineering, LLC.&nbsp;&ndash;&nbsp;Go Far. Go Together.</title><link rel="stylesheet" href="/css/core.min.6fe5d1dee32d5c1f625e8d9d541db5df28b4c99bf9f600cc7284f342438549386d2338be608f2edbb2e7fef8cbcccf30.css" integrity="sha384-b&#43;XR3uMtXB9iXo2dVB213yi0yZv59gDMcoTzQkOFSThtIzi&#43;YI8u27Ln/vjLzM8w"><link rel="alternate" type="application/rss+xml" href="/index.xml" title="Quiescent Engineering, LLC." /><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Quiescent Engineering, LLC." /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">Quiescent Engineering, LLC.</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="/posts">Blog</a><a class="nav item" href="/about">About</a></nav></div></span></div><div class="site slogan"><span class="title">Go Far. Go Together.</span></div></section><section id="content"><ul class="note list"><li class="item"><a class="note" href="/2012/02/compile-time-polymorphism/">
            <p class="note title">Compile-Time Polymorphism</p><p class="note date">Sunday, February 5, 2012</p><p class="note content">Polymorphism is a tool in object orientation, which allows us to model behavior, while simultaneously leverage existing code. Polymorphism allows is behavior reuse. In C++ polymorphism, comes in 2 flavors, the standard runtime variant, and a curious compile time variant. Runtime polymorphism, like Java, leverages virtual functions to dynamically bind[1. With virtual functions the compiler doesn&rsquo;t know which method to call until runtime. In C++ this is implemented with the virtual method table] a method at the call site.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/idiom/">Idiom</a><a class="tag" href="/tags/c&#43;&#43;/">C&#43;&#43;</a><a class="tag" href="/tags/idiom/">idiom</a><a class="tag" href="/tags/performance/">performance</a><a class="tag" href="/tags/template/">template</a><a class="tag" href="/tags/virtual/">virtual</a></p></li><li class="item"><a class="note" href="/2012/01/modern-c/">
            <p class="note title">Modern C++</p><p class="note date">Sunday, January 22, 2012</p><p class="note content">I found an awesome talk on how the new changes of C++11 are modernizing, an already fantastically powerful language. http://channel9.msdn.com/Events/BUILD/BUILD2011/TOOL-835T.
In this talk, Herb Sutter does two things I feel are quite admirable. Firstly, despite this being a Microsoft conference, he talks only about standard, portable C++ until the final minutes.
Secondly, he very clearly, compares idioms we currently use, to the new C++11 idioms. This made it very easy for me to see the value of what C++11 provides.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/c&#43;&#43;/">C&#43;&#43;</a></p></li><li class="item"><a class="note" href="/2012/01/abusing-ram/">
            <p class="note title">Abusing RAM</p><p class="note date">Sunday, January 22, 2012</p><p class="note content">My system has 16GB of RAM, but since I run Linux I rarely use more than about 3GB. So how do I justify such a extreme amounts of memory? Ramdisks.
I run Lubuntu1, but hopefully this works for you too. Basically, I create a ramdisk and mount it in /mnt/ramdisk, then I setup the login/logout scripts to transfer to and from the ramdisk.
Step 1: Create a ramdisk Add this line to your fstab:<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/productivity/">productivity</a></p></li><li class="item"><a class="note" href="/2011/11/parallel-binary-buddy-the-friendly-memory-manager/">
            <p class="note title">Parallel Binary Buddy: The Friendly Memory Manager</p><p class="note date">Wednesday, November 23, 2011</p><p class="note content">Fragmentation, the allocator&rsquo;s sin. Each byte A buddy, A friend
 Introduction
Memory management is pervasive in all forms of software, not just operating systems. Embedded Systems, when dynamic memory is acceptable, tend to use memory pools to the heap. Standard desktop applications use the platform&rsquo;s std::new or malloc. However, when a system is more complex, a memory manager may be used. Memory managers allow the programmer to strictly control application memory, in a way that flows with the rest of the system&rsquo;s design.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/c&#43;&#43;/">C&#43;&#43;</a></p></li><li class="item"><a class="note" href="/2011/10/making-c-like-python-the-anderson-smart-pointer-pattern/">
            <p class="note title">Making C++ like Python: The Anderson Smart Pointer Pattern</p><p class="note date">Sunday, October 23, 2011</p><p class="note content">Choosing to use C++ brings the additional complexity of memory management. Dennis Ritchie once stated: The C Programming Language — A language which combines the flexibility of assembly language with the power of assembly language. C++ inherits much of that _flexibility, _however, this incidental complexity, can be relegated to a single class, leaving you with the high-level elegance of Python. RAII help with this additional complexity, however without a pattern for guidance implementing RAII consistently can be difficult, defeating the safety it provides.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/productivity/">Productivity</a><a class="tag" href="/tags/c&#43;&#43;/">C&#43;&#43;</a><a class="tag" href="/tags/d/">D</a><a class="tag" href="/tags/memory/">memory</a><a class="tag" href="/tags/python/">Python</a><a class="tag" href="/tags/raii/">RAII</a></p></li><li class="item"><a class="note" href="/2011/10/parallel-game-of-life/">
            <p class="note title">Parallel Game-of-Life</p><p class="note date">Sunday, October 23, 2011</p><p class="note content">Conway&rsquo;s Game of Life is a dramatic illustration of emmergent behavior; that a seemingly complex system, such as cell mitosis can be governed by a set of simple rules. OpenMP is a fantastic set of language extensions which allows one to add dramatic parallelism without complex thread management. As a demonstration of OpenMP&rsquo;s simplicity I implemented the Game of Life. The code and all analysis is available on bitbucket.org.
In a real program, it common to have swathes of code which cannot be made parallel.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/parallelism/">Parallelism</a><a class="tag" href="/tags/c&#43;&#43;/">C&#43;&#43;</a><a class="tag" href="/tags/parallel/">parallel</a></p></li><li class="item"><a class="note" href="/2011/09/the-1000000-compile/">
            <p class="note title">The $1,000,000 Compile</p><p class="note date">Thursday, September 22, 2011</p><p class="note content">Hitting the compile and run button costs $1,000,000. How would such a cost affect your test strategy? As extreme as that sounds, its a harsh reality for ASIC designers. The start-up costs for an ASIC design are extreme, as a result ASIC verification is very important. Especially since you can&rsquo;t just update a buggy ASIC. In software engineering, we design increasingly complex systems requiring more and more elegant test strategies. I propose ASIC verification is in a more mature state, and software engineers could learn a lot from the translation of these techniques.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/left-field/">Left-Field</a><a class="tag" href="/tags/testing/">testing</a></p></li><li class="item"><a class="note" href="/2011/08/good-tools-excellent-results/">
            <p class="note title">Good Tools, Excellent Results</p><p class="note date">Sunday, August 21, 2011</p><p class="note content">This semester for the C++ practicum we are building a clone of Zork. Like many games of the genre, Zork is driven by a database. Our implementation is a JSON database. I chose JSON for a few reasons, but most importantly because its a human readable format that&rsquo;s simple to understand. I started by editing JSON files by hand in a text editor, however I found very quickly that investigating in a quick tool greatly improved my quality.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/c&#43;&#43;-practicum/">C&#43;&#43; Practicum</a><a class="tag" href="/tags/c&#43;&#43;/">C&#43;&#43;</a><a class="tag" href="/tags/productivity/">productivity</a><a class="tag" href="/tags/python/">Python</a><a class="tag" href="/tags/tools/">tools</a></p></li><li class="item"><a class="note" href="/2011/08/why-do-some-tutorials-use-stdcout-and-others-use-just-cout/">
            <p class="note title">Why do some tutorials use std::cout and others use just cout?</p><p class="note date">Friday, August 19, 2011</p><p class="note content">#include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl; return 0; }  However sometimes, and in my opinion the more correct version is written:
#include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl; return 0; }  The difference between the 2 programs is the double colon (::). This is called the namespace resolution operator. C++ has a wonderful concept called namespaces. Namespaces allow you to group or organize sets of objects into named collections.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/c&#43;&#43;-beginner/">C&#43;&#43; Beginner</a><a class="tag" href="/tags/tutorial/">tutorial</a></p></li><li class="item"><a class="note" href="/2011/08/hijacking-system-programs/">
            <p class="note title">Hijacking System Programs</p><p class="note date">Friday, August 12, 2011</p><p class="note content">Let&rsquo;s say for a moment that you are a graduate student, with shell access to your schools server. The server maintains a number of tools you need for classes, and research. All is well, except the stock editor on the server is wicked old. Like an eternity old. Well that happened to me. I am fully addicted to my custom vim configuration, but it requires vim7.3. My school&rsquo;s server only has 7.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/productivity/">Productivity</a><a class="tag" href="/tags/command-line/">command line</a><a class="tag" href="/tags/customize/">customize</a><a class="tag" href="/tags/vim/">vim</a></p></li></ul><div class="pagination">
    <ul><li><a href="/page/5/"><span class="iconfont icon-pagepreview"></span></a></li><li><a class="active" href="/page/6/">6</a></li><li><a class="" href="/page/7/">7</a></li><li><a class="" href="/page/8/">8</a></li></ul>
</div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">©2020 Jeremy Wright</p>
    <p class="powerby"><span>Powered by </span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p></div></section></body>

</html>