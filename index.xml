<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The Quiescent Current</title>
    <link>https://quiescent.us/</link>
    <description>Recent content on The Quiescent Current</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>©2022 Jeremy Wright</copyright>
    <lastBuildDate>Sun, 24 Apr 2022 00:00:00 -0700</lastBuildDate><atom:link href="https://quiescent.us/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>How to write a thesis or capstone 10 minutes at a time | How I learn deeply and permanently</title>
      <link>https://quiescent.us/2022/04/how-to-write-a-thesis/</link>
      <pubDate>Sun, 24 Apr 2022 00:00:00 -0700</pubDate>
      
      <guid>https://quiescent.us/2022/04/how-to-write-a-thesis/</guid>
      <description>I think the most challenging aspect of school is learning how you learn. Ironically, &amp;ldquo;smarter&amp;rdquo; people tend to get away with less need to reflect on their own process to learn 1. The are simply able to just absorb more &amp;ldquo;naturally&amp;rdquo;.
I have not been such an individual. My learning required a deliberate process. This thing I&amp;rsquo;ve found that works best is diligent regular practice. This however has the benefit of being useful for busy people.</description>
    </item>
    
    <item>
      <title>What can&#39;t flowcharts do?</title>
      <link>https://quiescent.us/2022/04/flowcharts-cant/</link>
      <pubDate>Sun, 24 Apr 2022 00:00:00 -0700</pubDate>
      
      <guid>https://quiescent.us/2022/04/flowcharts-cant/</guid>
      <description>When we begin programming we&amp;rsquo;re often taught to start with flowcharts. This is not bad advice. Flowcharts are a tool to help you slowdown and focus on an ordering of events or actions. Together these actions achieve some outcome. This series of actions to achieve an outcome we call an algorithm. Great! Now we&amp;rsquo;re really programming. However, it can seem (at the beginning) that flowcharts can capture any set of ordered work.</description>
    </item>
    
    <item>
      <title>Modulus in 5 minutes</title>
      <link>https://quiescent.us/2022/04/5-min-pointers/</link>
      <pubDate>Tue, 05 Apr 2022 00:00:00 -0700</pubDate>
      
      <guid>https://quiescent.us/2022/04/5-min-pointers/</guid>
      <description>   </description>
    </item>
    
    <item>
      <title>Pointers in 5 minutes</title>
      <link>https://quiescent.us/2022/04/5-min-pointers/</link>
      <pubDate>Tue, 05 Apr 2022 00:00:00 -0700</pubDate>
      
      <guid>https://quiescent.us/2022/04/5-min-pointers/</guid>
      <description>   </description>
    </item>
    
    <item>
      <title>Why is bool one byte: Wasting space to save time</title>
      <link>https://quiescent.us/2021/11/why-bool-is-one-byte/</link>
      <pubDate>Sun, 28 Nov 2021 00:00:00 -0700</pubDate>
      
      <guid>https://quiescent.us/2021/11/why-bool-is-one-byte/</guid>
      <description>Boolean carries 1 bit of information. The canonical example of binary, On/Off, True/False. Yet, the bool type in C and C++ is 1 byte large, 8 bits of information. Carrying thus $$2^8 = 256$$ representable values. This may not sound like much, but consider an array of bools (a common misunderstanding beginning C++ students make trying to formulate a bit-field): bool fatBitField[8]
This wasted space however has a useful purpose. It a common reason in many optimizations we make in data structures, we trade space for time.</description>
    </item>
    
    <item>
      <title>21st Century Proof :: Structure makes it possible, hard work makes it probable</title>
      <link>https://quiescent.us/2021/09/twenty-first-century-proof/</link>
      <pubDate>Mon, 13 Sep 2021 00:00:00 -0700</pubDate>
      
      <guid>https://quiescent.us/2021/09/twenty-first-century-proof/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;A new way of expressing: &amp;ldquo;work smarter not harder&amp;rdquo; -&amp;gt; Structure makes it possible, hard work makes it probable.&lt;/li&gt;
&lt;li&gt;Detail can obscure the big picture. Structure can help, if it allows for a personalized, or tunable about of illumination.&lt;/li&gt;
&lt;li&gt;A proof is not easy if we must read the entire proof to understand.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://lamport.azurewebsites.net/pubs/proof.pdf&#34;&gt;Source&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>My TLA&#43; Saga</title>
      <link>https://quiescent.us/2021/09/my-tla-saga/</link>
      <pubDate>Wed, 08 Sep 2021 00:00:00 -0700</pubDate>
      
      <guid>https://quiescent.us/2021/09/my-tla-saga/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Learning together is more fun, and you may not be as self-taught as you believe.&lt;/li&gt;
&lt;li&gt;The stories we tell ourselves deeply impact our ability (or inability) to grow.&lt;/li&gt;
&lt;li&gt;The more you learn, the more challenging the material becomes to continue growing. (a.k.a. Duh, but it took me time to realize it, regardless)&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Write a Scheme (Log)</title>
      <link>https://quiescent.us/series/write-a-scheme/write-a-scheme/</link>
      <pubDate>Thu, 25 Mar 2021 15:00:14 -0700</pubDate>
      
      <guid>https://quiescent.us/series/write-a-scheme/write-a-scheme/</guid>
      <description>Running post/diary of my Write You a Scheme
I&amp;rsquo;m testing the idea of an Luhmann Index, or Map of Content, as this work log expands to link into posts and interestingness the effort generates.
2022-04-15  Basic Parsing work. I can parse some patterns into Either types or parse error.  Questions  What is a combinator?  </description>
    </item>
    
    <item>
      <title>The World Is Not Incremental</title>
      <link>https://quiescent.us/2021/03/not-incremental/</link>
      <pubDate>Wed, 03 Mar 2021 15:00:00 -0700</pubDate>
      
      <guid>https://quiescent.us/2021/03/not-incremental/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve been struggling to understand the stress the TLA⁺ community is putting on the presence of &lt;em&gt;math&lt;/em&gt; in the  specifications.
Namely, that specifications are not programming, and the math simplifies, by abstraction, the system.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;What exactly is being simplified by using math, instead of &amp;ldquo;programming&amp;rdquo;?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;During TLA⁺ study group this week, we discussed at least 1 aspect that applying math simplifies the description of our systems $$\rightarrow$$ The number of states.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Using QuickCheck&#39;s Positive Type Level Modifier</title>
      <link>https://quiescent.us/2020/12/quickcheck-type-level-modifiers/</link>
      <pubDate>Thu, 24 Dec 2020 00:00:00 -0700</pubDate>
      
      <guid>https://quiescent.us/2020/12/quickcheck-type-level-modifiers/</guid>
      <description>One of my students this semester was struggling with the material. This student is a very diligent worker and has been researching the problems trying to get a better understanding of the material before digging in. Sometimes however, there is no replacement for just digging in and coding something. This does at least two things, it solidifies the material you&amp;rsquo;re read so far, and most importantly it shows you the limits of what you currently understand and urges you to learn more.</description>
    </item>
    
    <item>
      <title>About Me</title>
      <link>https://quiescent.us/about/</link>
      <pubDate>Sun, 20 Dec 2020 17:30:00 -0700</pubDate>
      
      <guid>https://quiescent.us/about/</guid>
      <description>When you do things right, no one can be sure you did anything at all.
— Futurama Season 3
 If you find one my posts or videos helpful perhaps buy me a ${coffee|context.suitableBeverage()}
I specialize in the software no one sees. The high performance, concurrent, hard real-time, high-reliability systems that enable our way of life.
My software fights fraud, and drives tractors. I&amp;rsquo;ve baked solar cells, made escalators more efficient, optimized fantasy sports.</description>
    </item>
    
    <item>
      <title>My Learning Process</title>
      <link>https://quiescent.us/2020/05/learning-process/</link>
      <pubDate>Mon, 25 May 2020 15:31:21 -0700</pubDate>
      
      <guid>https://quiescent.us/2020/05/learning-process/</guid>
      <description>Update 2022-04: I&amp;rsquo;ve improved this process. How to write a thesis
 Learning Questions My learning process consists of a set of learning questions. These questions are almost certainly wrong and reflect at least the following:
 My motivation for learning a topic. My misconceptions of a given topic and the seemingly magic qualities a beginner believes it can provide.  The learning questions are initially, almost certainly wrong. This is good.</description>
    </item>
    
    <item>
      <title>System languages should include Webapps</title>
      <link>https://quiescent.us/2015/10/system-languages-include-web/</link>
      <pubDate>Sat, 03 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://quiescent.us/2015/10/system-languages-include-web/</guid>
      <description>I was reading an FAQ today about some subtle C++ point and I came across a comment that explicitly excludes the beginning language-learner.
 By the way, it confuses most novice C++ programmers that private virtuals can be overridden&amp;hellip; However the private virtual approach is now common enough that confusion of novices is less of a concern.
 This left me frustrated that a language that has been core to my personal success so flippantly brushed aside its future user.</description>
    </item>
    
    <item>
      <title>4 Simple Steps to Run D Language in Azure Websites</title>
      <link>https://quiescent.us/2015/09/deploying-d-to-azure-webapp/</link>
      <pubDate>Fri, 25 Sep 2015 20:10:00 +0700</pubDate>
      
      <guid>https://quiescent.us/2015/09/deploying-d-to-azure-webapp/</guid>
      <description>I shameless stole these steps from 4 Simple Steps to Run Go Language in Azure Websites. This post is simply a transliteration to D. Thank you very much to Wade Wegner for the original post.
4 Simple Steps  Create your Azure Website in Azure Portal.  Configure FTP deployment    2. Run dub init vibed_hello_world --type=vibe.d and change the default app.d to read the port from an environment variable.</description>
    </item>
    
    <item>
      <title>Property Driven Design: MinMax</title>
      <link>https://quiescent.us/2015/07/property_driven_design_minmax/</link>
      <pubDate>Sun, 05 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://quiescent.us/2015/07/property_driven_design_minmax/</guid>
      <description>&lt;p&gt;I wrote an article on &lt;a href=&#34;http://www.codestrokes.com/2014/09/property-testing-in-c/&#34;&gt;Property Testing&lt;/a&gt;
about a year ago. Isocpp.org even &lt;a href=&#34;https://isocpp.org/blog/2014/12/property-testing&#34;&gt;linked to
it&lt;/a&gt; which was pretty cool.
Recently, I uncovered a fantastic talk by &lt;a href=&#34;https://www.youtube.com/watch?v=shngiiBfD80&#34;&gt;Jessica Kerr about property
testing&lt;/a&gt;. Kerr&amp;rsquo;s talk
reinvigorated my languid research effort toward generated testing. Kerr
presented the idea (novel to me) that properties aren&amp;rsquo;t rigid. Properties
don&amp;rsquo;t need to exclude all possible incorrect results for a given function.
Properties simply must &lt;em&gt;reduce the size&lt;/em&gt; of the incorrect space. This may seem
like semantics, but it is easier to exclude a wild-ass-guess that verify it is correct.
Additionally, some domains may not have a solidly defined answer,a nd the
result my be probabilistic in nature. This post will focus on deterministic
problems for the moment, but realize that property testing is vastly more
general than mundane example testing. How properties reduce the size of the
problem space makes me imagine this Figure.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://quiescent.us/img/Properties_solution_space.png&#34; alt=&#34;sometimes_code_gives_you_a_wtf&#34;&gt;&lt;/p&gt;
&lt;p&gt;Following Kerr&amp;rsquo;s references, I found a set of projects from a &lt;a href=&#34;http://www.cs.ou.edu/~rlpage/SEcollab/20projects/&#34;&gt;predicate-logic
course&lt;/a&gt;. This course
provides 20 separate projects excellently cast for a property-driven-design
tutorial. These projects are unique since besides the typical requirements
they enumerate the predicate functions each requirement typifies. Predicate
functions are to a predicate-logician as properties are to a computer
scientist. These enumerated properties (predicates) clarified
many points I misunderstood about property testing.&lt;/p&gt;
&lt;p&gt;This post will step through the design of the first project
&lt;a href=&#34;http://www.cs.ou.edu/~rlpage/SEcollab/20projects/minmax.htm&#34;&gt;minmax&lt;/a&gt; using
C++. My primary goal for this article is to address a concern raised by
a colleague, &amp;ldquo;Does pulling in more complexity — a fancy test
generator — actually increase quality?&amp;rdquo;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/JeremyLWright/property_driven_design/tree/master/01_minmax&#34;&gt;Code for this article&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/JeremyLWright/JeremyLWright.github.io/commits/content/content/posts/2015-07-05-property_driven_design_minmax.markdown&#34;&gt;Revision Log for this article&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Recasting how I blog</title>
      <link>https://quiescent.us/2015/06/converting-to-static-blog/</link>
      <pubDate>Sun, 07 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://quiescent.us/2015/06/converting-to-static-blog/</guid>
      <description>&lt;p&gt;I wrote my first article for codestrokes in February 2011 - right as I was
accepted to graduate school. My goal was to improve my writing in preparation
for writing a thesis. While through grad school I started with more
traditional writing tool. I started to learn to write, and I found my writing
style: Simplicity.  I started writing with a big fancy word processor.
I blogged with a massive database backed blogging engine. By the time
I finished my thesis, I was writing in vim. I used a makefile to check
spelling and check for simple grammatical rules. The process was much simpler
to manage. This motivated me to convert my blog to a static site. This post
describes my process on simplifying my writing process.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Introduction to Pointers</title>
      <link>https://quiescent.us/2015/02/introduction-to-pointers/</link>
      <pubDate>Tue, 17 Feb 2015 03:46:55 +0000</pubDate>
      
      <guid>https://quiescent.us/2015/02/introduction-to-pointers/</guid>
      <description>Please see my introduction to pointers at https://www.youtube.com/watch?v=mkYBz5Db-Ok.</description>
    </item>
    
    <item>
      <title>Property Testing in C&#43;&#43;</title>
      <link>https://quiescent.us/2014/09/property-testing-in-c/</link>
      <pubDate>Wed, 03 Sep 2014 23:00:00 -0700</pubDate>
      
      <guid>https://quiescent.us/2014/09/property-testing-in-c/</guid>
      <description>&lt;p&gt;
Currently, I&#39;m on a testing kick. One might say tests are shiny. I don&#39;t
know if they are really shiny as much as I found another cool use for
uniform_int_distribution&lt;&gt;. A use which, as a side effect, might make me
appear to be a better software developer. (This assumes a negative bug rate is
proportional to better software). I&#39;ve started playing with Property Testing.
Property Testing is a form of unit testing where the programmers defines
properties, or invariants about the code. A &lt;del&gt;framework&lt;/del&gt; library (ok,
seriously its a framework because it calls your code) generates random
constrained inputs and calls your test functions. It&#39;s pretty cool, and while
I was playing around with the framework, I found a real bug, related to my
ignorance of C++&#39;s auto type deduction.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>What is a Unit Test?</title>
      <link>https://quiescent.us/2014/08/what-is-a-unit-test/</link>
      <pubDate>Thu, 28 Aug 2014 05:58:26 +0000</pubDate>
      
      <guid>https://quiescent.us/2014/08/what-is-a-unit-test/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m taking a Software Testing and Verification course as part of my Master&amp;rsquo;s work. Our first assignment was to write a short paper describing a unit test, then implement selection sort and test it under that philosophy. Sarcastically, I commented to my colleagues the triviality of this question. The first response was, &amp;ldquo;Wow, I don&amp;rsquo;t think that is such an easy question.&amp;rdquo; A technical discussion ensued. This is that log.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Hello Project Euler, Sorry I doubted you</title>
      <link>https://quiescent.us/2014/08/hello-project-euler-sorry-i-doubted-you/</link>
      <pubDate>Thu, 28 Aug 2014 05:04:52 +0000</pubDate>
      
      <guid>https://quiescent.us/2014/08/hello-project-euler-sorry-i-doubted-you/</guid>
      <description>Project Euler returns with full functionality including new problems! Thank you Project Euler for not giving up on this awesome project. http://projecteuler.net/news</description>
    </item>
    
    <item>
      <title>Goodbye Project Euler</title>
      <link>https://quiescent.us/2014/06/goodbye-project-euler/</link>
      <pubDate>Wed, 18 Jun 2014 15:42:22 +0000</pubDate>
      
      <guid>https://quiescent.us/2014/06/goodbye-project-euler/</guid>
      <description>A group of friends and I have been working on project euler for about a year now. I learned a great deal from this fantastic project, and it was the first time I was able to get a real handle on Haskell. Project Euler taught me make. It taught me better performance reporting techniques, honed my octave, and got me over that initial mind bending hump of Haskell. Thank you Project Euler, you will be missed.</description>
    </item>
    
    <item>
      <title>Design for Testability via Security </title>
      <link>https://quiescent.us/2014/05/design-for-testability-via-security/</link>
      <pubDate>Sat, 03 May 2014 20:56:49 +0000</pubDate>
      
      <guid>https://quiescent.us/2014/05/design-for-testability-via-security/</guid>
      <description>&lt;p&gt;I was discussing bootloader design with a colleague of mine the other day. We were attempting to load new a third-party hardware component. The device has a poor protocol, and a useless verification step. This discussion got me thinking however how the concepts used to build a strong self-enforcing security protocol, also apply to building a testable, and reliable communication protocol. Thus, security helps us build better products not because they are secure, but because they are verifiable.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Massively Intelligent Non-Deterministic Luminating Effortless Super Solver</title>
      <link>https://quiescent.us/2014/02/cracking-subciphercpp/</link>
      <pubDate>Wed, 12 Feb 2014 08:50:00 -0700</pubDate>
      
      <guid>https://quiescent.us/2014/02/cracking-subciphercpp/</guid>
      <description>&lt;p&gt;I worked the title of this article several times before I finally settled on the subtly epic heading you see above. Hopefully this title will funnel people off google into my blog (delicious SEO). I wanted to push the A.I. component of my solution because A.I. is awesome and mysterious, and cool (and can like solve jeopardy). I was quickly disillusioned however. Really, A.I. isn&amp;rsquo;t magic, rather it&amp;rsquo;s just the same thing computers have been doing for a long time: computing. Sadly this realization took several months in an A.I. class before I was sufficiently crestfallen. A.I. patterns including the hill climbing algorithm used here are indeed &amp;ldquo;intelligent&amp;rdquo; but really it a reflecting of the algorithm designer, not the entity executing the algorithm. So I built a substitution cipher solver in C++. It&amp;rsquo;s fast it uses random numbers i.e. non-deterministic, it uses an A.I. algorithm i.e. Intelligent, it uses threads i.e. Massively, it deciphers i.e. luminates the text and it solves super stuff therefore the title is completely justified. I give you my Massively Intelligent Non-Deterministic Luminating Effortless Super Solver (MINDLESS). If none of that interests you then please stick around and follow the side quest of looking for &lt;a href=&#34;http://justenoughcraig.blogspot.com/2014/01/just-say-no-to-passive-aggressive.html&#34;&gt;emotionally charged parenthesis&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Sean Parent: No Raw Loops</title>
      <link>https://quiescent.us/2013/11/sean-parent-no-raw-loops/</link>
      <pubDate>Sun, 24 Nov 2013 22:14:50 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/11/sean-parent-no-raw-loops/</guid>
      <description>&lt;p&gt;A group of colleagues and I watched Sean Parent&amp;rsquo;s Going Native Talk on &amp;ldquo;&lt;a href=&#34;http://channel9.msdn.com/Events/GoingNative/2013/Cpp-Seasoning&#34;&gt;C++ Seasoning&lt;/a&gt;&amp;rdquo;. Parent takes some extreme views on how to use C++, but his examples for using the STL to simplify code are phenomenal. For a recent AI project I decided to apply Parent&amp;rsquo;s &lt;em&gt;goal&lt;/em&gt; of &amp;ldquo;no raw loops&amp;rdquo;, I was blown away by the transformation&amp;hellip; err std::transformation this had on my code. In this post I indented to demonstrate several complex code blocks, or overly specific code blocks what were replaced by some STL magic. Alexander Stepanov says, &amp;ldquo;&lt;a href=&#34;http://www.youtube.com/watch?v=COuHLky7E2Q&#34;&gt;&amp;hellip;code is a liability.&lt;/a&gt;&amp;rdquo; The more code a program has the more likely it contains bugs. The fewer lines of code, the lesser the opportunity for a bug. I haven&amp;rsquo;t quiet decided if I agree with this point, but it does induce thought either way. Sean Parent&amp;rsquo;s methodology seems to agree, for the purposes of this post we&amp;rsquo;ll agree as well.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>rand() Considered Harmful</title>
      <link>https://quiescent.us/2013/11/rand-considered-harmful/</link>
      <pubDate>Sun, 17 Nov 2013 16:54:19 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/11/rand-considered-harmful/</guid>
      <description>Stephan T Lavavej (STL) is a tactical speaker. In a short amount of time he convey&amp;rsquo;s essential accurate information which is immediately applicable. In this talk at Going Native 2013, STL takes 20 minutes to teach us how to properly use random numbers in our programs: http://channel9.msdn.com/Events/GoingNative/2013/rand-Considered-Harmful</description>
    </item>
    
    <item>
      <title>Simplicity Does Matter!</title>
      <link>https://quiescent.us/2013/11/simplicity-does-matter/</link>
      <pubDate>Tue, 12 Nov 2013 05:56:28 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/11/simplicity-does-matter/</guid>
      <description>I&amp;rsquo;m been sitting this draft for too long, but before I started my research experiment with Haskell I was looking for a language. I was approaching an AI class for my graduate work, and thought I&amp;rsquo;d learn Lisp, or at least a lisp. Clojure was hot, and new (read shiny), so I dove into learning about it&amp;rsquo;s virtues. It&amp;rsquo;s virtues are embodied in its creator, Rich Hickey, who while being a great programmer is a fantastic speaker.</description>
    </item>
    
    <item>
      <title>A Thunk on Laziness</title>
      <link>https://quiescent.us/2013/10/a-thunk-on-laziness/</link>
      <pubDate>Sun, 27 Oct 2013 23:00:17 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/10/a-thunk-on-laziness/</guid>
      <description>&lt;p&gt;I originally approached Haskell excited, and wide-eyed mystified by the type theory. Type became my golden hammer. In my C programs I typedef&amp;rsquo;d everything so it&amp;rsquo;d have a &amp;ldquo;unique&amp;rdquo; type. I was cautious with my casting. I was hooked. I had an intuitive understanding of laziness, as implemented by Haskell, that would allow one to write&amp;quot;streaming&amp;quot; algorithms. That is programs that deal with data in an online way to process data as it streams through. While that maybe true, you know what else can do that? C.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Idiomatic Learning</title>
      <link>https://quiescent.us/2013/10/idiomatic-learning/</link>
      <pubDate>Sun, 20 Oct 2013 23:00:00 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/10/idiomatic-learning/</guid>
      <description>&lt;p&gt;When learning a new language I find it helpful to study a languages idioms. Idioms exist in a language for a specific reason. Sometimes that reason is to further the principles of the language, other times it’s to mask, or otherwise deal with some underlying design decision of the language. Currently, I am studying Haskell, and currently I am struggle to clarify the idioms of the language. The syntax is still very new and awkward, currently with a total authoring in Haskell of 713 lines.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>&#34;Smaller&#34; Reviews are More Effective</title>
      <link>https://quiescent.us/2013/10/smaller-reviews-are-more-effective/</link>
      <pubDate>Sun, 13 Oct 2013 23:00:23 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/10/smaller-reviews-are-more-effective/</guid>
      <description>&lt;p&gt;I was reviewing a new software module for work today, and discovered that when the class fit on a single screen my comments were more meaningful, than when the class was larger.  My comments for spatially larger classes were mostly focused on syntactic, and idiomatic details. It was an interesting self-observation, but this certainly isn&amp;rsquo;t new information.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>The Itanium Flop</title>
      <link>https://quiescent.us/2013/10/the-itanium-flop/</link>
      <pubDate>Mon, 07 Oct 2013 01:23:13 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/10/the-itanium-flop/</guid>
      <description>&lt;p&gt;I wake up in the morning with ideas that please me, and some of those ideas actually please me also later in the day when I&amp;rsquo;ve entered them into my computer. - Donald Knuth&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;m on a bit of a Knuth kick right now, and I&amp;rsquo;ve been procrastinating studying, and homework to find interviews, and papers by the master himself. I currently have a list of microfiche references to check out as soon as I get to the basement of my university&amp;rsquo;s library: Woot, &lt;a href=&#34;http://www.chrisfenton.com/homebrew-cray-1a/&#34;&gt;computational necromancy&lt;/a&gt;! Through this, I came across a quote in an &lt;a href=&#34;http://www.informit.com/articles/article.aspx?p=1193856&#34;&gt;interview&lt;/a&gt;, &amp;ldquo;&amp;hellip;worse than the &amp;ldquo;&lt;a href=&#34;http://en.wikipedia.org/wiki/Itanium&#34;&gt;Itanium&lt;/a&gt;&amp;rdquo; approach that was supposed to be so terrific—until it turned out that the wished-for compilers were basically impossible to write.&amp;rdquo; What? I thought it was simply market forces that drive the x86-64 ahead of Itanium: nope!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Linux User&#39;s Group CTF 2013</title>
      <link>https://quiescent.us/2013/09/linux-users-group-ctf-2013/</link>
      <pubDate>Sun, 08 Sep 2013 21:58:06 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/09/linux-users-group-ctf-2013/</guid>
      <description>&lt;p&gt;This past weekend we held another capture the flag event at the Arizona State University&amp;rsquo;s Linux User&amp;rsquo;s Group. It had more of a system admin focus than security cracking exploits, but it was fun an nontheless a diverse learning experience for all those involved. However, almost immediately, I realized the number one rule in CTF, nothing is off limits!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>My First Logic Program</title>
      <link>https://quiescent.us/2013/09/my-first-logic-program/</link>
      <pubDate>Sun, 01 Sep 2013 22:35:41 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/09/my-first-logic-program/</guid>
      <description>&lt;p&gt;This semester, I&amp;rsquo;m taking an introduction to artificial intelligence, and despite this being the second week, I&amp;rsquo;ve learned a great deal. Our second assignment was to implement a program in clingo (clasp on gringo) which is a derivative of Prologue. This is my first experience with a logical programming language, and I am intrigued to the possibilities.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Artifical Intelligence Impact on Medicine</title>
      <link>https://quiescent.us/2013/08/artifical-intelligence-impact-on-medicine/</link>
      <pubDate>Wed, 28 Aug 2013 20:16:38 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/08/artifical-intelligence-impact-on-medicine/</guid>
      <description>&lt;p&gt;Dr. Andrew Weil of the Arizona Center for Integrative Medicine states, “If we can make the correct diagnosis, the healing can begin. If we can’t, both our personal health and our economy are doomed. [1]” Accurate, traceable, and informed diagnosis are paramount to the health of patients. Medicine, within the United States, is an enormous $2.5 Trillion opportunity and with the proliferation of research over many decades new medical findings are being published than could ever be grokked, unassisted, by a doctor [2]. Current advances in data mining have moved to alleviate the shear volume of information available to doctors. Medical data mining offers doctors the tools to distinguish anomalies from trending epidemics; the tools to make evidence based decisions, ultimately leading to more personalized medicine [2].&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Interesting article about Monads</title>
      <link>https://quiescent.us/2013/08/interesting-article-about-monads/</link>
      <pubDate>Fri, 02 Aug 2013 22:49:01 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/08/interesting-article-about-monads/</guid>
      <description>I found an interesting blog today with some clear and interesting discussion on Haskell, and Monads: http://intoverflow.wordpress.com/2010/07/20/i-come-from-java-and-want-to-know-what-monads-are-in-haskell/</description>
    </item>
    
    <item>
      <title>My Haskell Environment for Project Euler</title>
      <link>https://quiescent.us/2013/08/my-haskell-environment-for-project-euler/</link>
      <pubDate>Fri, 02 Aug 2013 16:51:40 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/08/my-haskell-environment-for-project-euler/</guid>
      <description>&lt;p&gt;For the last several months I&amp;rsquo;ve been working on Project Euler in Haskell. My intent has been to learn Haskell, and grasp the functional concepts. While working on several problems it&amp;rsquo;s important to have a workflow that allows for a fast cycle time. I spent some time with Cabal, attempting to build a scheme that works efficiently, but was unable to do so. Instead I setup a mix of cabal-dev, and make to build a fast workflow that allow for compiling, testing, common code libraries, and benchmarks. This post is a walk though of that workflow.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>How to Write a Thesis</title>
      <link>https://quiescent.us/2013/07/review-how-to-write-a-thesis-2/</link>
      <pubDate>Wed, 24 Jul 2013 04:48:01 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/07/review-how-to-write-a-thesis-2/</guid>
      <description>My family purchased this book for me, as a motivator to start thinking about the thesis component of my master&amp;rsquo;s degree. &amp;ldquo;It must be substantial&amp;hellip;&amp;rdquo; said a colleague of mine. &amp;ldquo;It must be original work&amp;hellip;&amp;rdquo; Original, substantial, all words that left me with uneasiness about how to start. This book however was an easy read, and gave some very pragmatic advice on how to start, yet the most important quote I drew from the book was, &amp;ldquo;What are the questions in your field?</description>
    </item>
    
    <item>
      <title>Is Monolithic Code Faster?</title>
      <link>https://quiescent.us/2013/07/is-monolithic-code-faster/</link>
      <pubDate>Sun, 14 Jul 2013 23:00:11 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/07/is-monolithic-code-faster/</guid>
      <description>&lt;p&gt;As a software engineer I have a vested interest in disproving this statement. Bjarne Stroustroup says C++ is designed to create efficient abstractions. A software engineer’s  job is to create simple &lt;a href=&#34;http://www.codestrokes.com/2012/09/abstraction-in-plain-english/&#34;&gt;abstractions &lt;/a&gt;to complex systems. State machines form a large part of many systems. The other day, a co-worker came to me, and asked, “Is it better to make straight line code for each case statement, even if it repeats, or is it better to abstraction into functions and make the code ‘cleaner’.”  Is “cleaner” code faster?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Patterns are evidence of a language&#39;s lacking</title>
      <link>https://quiescent.us/2013/07/patterns-are-evidence-of-a-languages-lacking/</link>
      <pubDate>Sun, 07 Jul 2013 23:00:30 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/07/patterns-are-evidence-of-a-languages-lacking/</guid>
      <description>&lt;p&gt;A coworker of mine stated something interesting, &amp;ldquo;&amp;hellip;a pattern is evidence of missing feature in the language&amp;hellip;&amp;rdquo;. At first I struggled with this statement. How can you design a language general enough to be widely used, and simultaneously cover all the desirable idioms such that patterns are built in? At first this seemed silly to me, until I heard Erik Meijer state in a Haskell lecture, &amp;ldquo;..this is why we implemented LINQ as a pattern instead of a language feature&amp;hellip;&amp;rdquo;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Haskell a Few Problems Later</title>
      <link>https://quiescent.us/2013/05/haskell-a-few-problems-later/</link>
      <pubDate>Tue, 14 May 2013 04:28:58 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/05/haskell-a-few-problems-later/</guid>
      <description>&lt;p&gt;Well, the Haskell honeymoon is over for me. I spent some time working on a few Project Euler problems this weekend, and my initial assumptions formed from toy problems were dashed. While I was able to solve 3 problems fairly quickly, I faced a number of non trivial bugs, and memory issues. On the other side of my naïve passion, I’m finding a functional thought process, and it’s exciting.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Haskell Day 1 (Again)</title>
      <link>https://quiescent.us/2013/04/haskell-day-1-again/</link>
      <pubDate>Mon, 22 Apr 2013 05:29:11 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/04/haskell-day-1-again/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve restarted my haskell programming education. Here is my implementation of &lt;a href=&#34;http://imranontech.com/2007/01/24/using-fizzbuzz-to-find-developers-who-grok-coding/&#34;&gt;FizzBuzz&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Latex Walkthrough</title>
      <link>https://quiescent.us/2013/03/latex-walkthrough/</link>
      <pubDate>Sun, 24 Mar 2013 18:25:50 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/03/latex-walkthrough/</guid>
      <description>Latex Walkthrough from Jeremy Wright on Vimeo.</description>
    </item>
    
    <item>
      <title>Beagle Board Cluster Demo&#39;d at ASU</title>
      <link>https://quiescent.us/2013/03/beagle-board-cluster-demod-at-asu/</link>
      <pubDate>Mon, 04 Mar 2013 19:09:31 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/03/beagle-board-cluster-demod-at-asu/</guid>
      <description>&lt;p&gt;We presented our Beagle Board Cluster at the Engineering Career Fair. Look out for a design writeup soon!&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://asulug.org/2013/03/engineering-open-house/&#34;&gt;http://asulug.org/2013/03/engineering-open-house/&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Duplicating SD Cards for Beagleboard</title>
      <link>https://quiescent.us/2013/02/duplicating-sd-cards-for-beagleboard/</link>
      <pubDate>Sun, 24 Feb 2013 16:38:11 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/02/duplicating-sd-cards-for-beagleboard/</guid>
      <description>&lt;p&gt;The ASU Linux User&amp;rsquo;s group is building a Beagleboard cluster. This requires each compute node to have an identical system image, with the exception of the hostname and ipaddress. The easiest way, I found to do this, is to configure one compute node, then duplicate the SD cards across the other nodes. Here is how I did that.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Text Processing for Programmers</title>
      <link>https://quiescent.us/2013/02/text-processing-for-programmers/</link>
      <pubDate>Sun, 17 Feb 2013 19:53:11 +0000</pubDate>
      
      <guid>https://quiescent.us/2013/02/text-processing-for-programmers/</guid>
      <description>&lt;p&gt;I was reading a &lt;a href=&#34;https://sites.google.com/site/steveyegge2/five-essential-phone-screen-questions&#34;&gt;blog &lt;/a&gt;about coding interviews, and one comment made near the bottom struck me, &amp;ldquo;&amp;hellip;&amp;ldquo;Um&amp;hellip; grep?&amp;rdquo; then they&amp;rsquo;re probably OK&amp;hellip;&amp;rdquo;  As I read that comment, I realized I&amp;rsquo;d never answer that way, and I agreed with the author that was a problem. That began my dabble in grep, awk and sed, and these tools will change your workflow and even how you think about profiling code.  Grep has even become a verb in my daily life, &amp;ldquo;Is this &lt;em&gt;greppable?&lt;/em&gt;&amp;rdquo; is my mantra.  Flash forward a few months and once again I had a task for these powerful text processing tools, convert a mysql database to sqlite. Sounds easy, but with file sizes of &amp;gt;700MB, you have to be efficient.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Short Valgrind Video Tutorial</title>
      <link>https://quiescent.us/2012/11/short-valgrind-video-tutorial/</link>
      <pubDate>Mon, 12 Nov 2012 03:40:11 +0000</pubDate>
      
      <guid>https://quiescent.us/2012/11/short-valgrind-video-tutorial/</guid>
      <description>I made a short video tutorial on valgrind. Enjoy
Valgrind Demonstration from Jeremy Wright on Vimeo.</description>
    </item>
    
    <item>
      <title>ASULUG Talk: Django Web Framework</title>
      <link>https://quiescent.us/2012/09/asulug-talk-django-web-framework/</link>
      <pubDate>Sat, 22 Sep 2012 15:36:10 +0000</pubDate>
      
      <guid>https://quiescent.us/2012/09/asulug-talk-django-web-framework/</guid>
      <description>ASU Linux User’s Group (ASULUG) — LUG Talks
Sat 6 Oct 1:30pm — BYENG 210
** **
The Django Web Framework
Jeremy Wright
Abstract
Django: Awesome Jazz Musician, Awesome Web Framework.
Django is a web framework similar to the popular Ruby on RAILS, but leveraging the Python programming language. Born out of the newspaper industry, Django is touted as the “web framework for perfectionists with deadlines.” Django is a powerful tool for any size web project: Web Services, Storefronts, CMS’s—Django conquers all.</description>
    </item>
    
    <item>
      <title>Abstraction in Plain English</title>
      <link>https://quiescent.us/2012/09/abstraction-in-plain-english/</link>
      <pubDate>Tue, 18 Sep 2012 23:11:51 +0000</pubDate>
      
      <guid>https://quiescent.us/2012/09/abstraction-in-plain-english/</guid>
      <description>&lt;p&gt;Abstraction is an interesting concept. For me personally, abstraction was never clearly explained. I left school and entered my first job knowing I should abstract things, but I realize now my understanding of abstraction amounted to obscurity.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Open Source CTF Game Server</title>
      <link>https://quiescent.us/2012/09/open-source-ctf-game-server/</link>
      <pubDate>Sun, 09 Sep 2012 17:30:50 +0000</pubDate>
      
      <guid>https://quiescent.us/2012/09/open-source-ctf-game-server/</guid>
      <description>I am releasing under Creative Commons Attribution-ShareAlike 3.0 Unported License. my django game server for running Capture the Flag events.
This server does have some known bugs which I enumerated in the issue tracker. I developed this first version for the Fall 2012 ASULUG hacking competition. I hope people can get involved and make this a fantastic game server! Please feel free to contact me, or simply fork the repository. I look forward to seeing everyone&amp;rsquo;s interesting pull requests!</description>
    </item>
    
    <item>
      <title>The Turbulent History of Managed Code</title>
      <link>https://quiescent.us/2012/08/the-turbulent-history-of-managed-code/</link>
      <pubDate>Tue, 28 Aug 2012 05:31:04 +0000</pubDate>
      
      <guid>https://quiescent.us/2012/08/the-turbulent-history-of-managed-code/</guid>
      <description>&lt;p&gt;Managed Code is a fascinating technology; Just-In-Time compilation provides advanced run-time optimization and strong type safety can &lt;a href=&#34;http://channel9.msdn.com/Shows/Going+Deep/Singularity-III-Revenge-of-the-SIP&#34;&gt;render the hardware MMU obsolete&lt;/a&gt;. However the managed code renaissance is again in decline, and interestingly more than technology, business is changing the managed/native landscape. More than any other other metric, managed code is about maximizing programmer productivity.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Know Its Name</title>
      <link>https://quiescent.us/2012/07/know-its-name/</link>
      <pubDate>Sat, 21 Jul 2012 19:24:19 +0000</pubDate>
      
      <guid>https://quiescent.us/2012/07/know-its-name/</guid>
      <description>Programming is at it&amp;rsquo;s heart an struggle in communication. Source code is the communication medium with the processor; Comment the medium to other coders, and UML the medium to higher-level communication. Computer Scientists have the stereotype of being poor communicators, but in our own mediums, we&amp;rsquo;re phenomenal. This fact is no where more apparent, than trying to explain source code to someone else. How does one read source code? I&amp;rsquo;m currently, learning Haskell, and my first goal is to understand this question.</description>
    </item>
    
    <item>
      <title>The Importance of System Design</title>
      <link>https://quiescent.us/2012/07/the-importance-of-system-design/</link>
      <pubDate>Sun, 15 Jul 2012 17:00:44 +0000</pubDate>
      
      <guid>https://quiescent.us/2012/07/the-importance-of-system-design/</guid>
      <description>&lt;p&gt;For the small programs we tend to implement as part of a semester project, or the simple &amp;ldquo;one-off/get-it-done&amp;rdquo; programs at work, system design rarely plays a part. However, even in the smallest problems a top-level system design is critical for consistency and ease of use. Class components, regardless of how precise and accurate they are in their own internal design, if they aren&amp;rsquo;t externally consistent with other objects, the system will be brittle, and difficult to use.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Building an Interpreter</title>
      <link>https://quiescent.us/2012/05/building-an-interpreter/</link>
      <pubDate>Mon, 28 May 2012 17:03:55 +0000</pubDate>
      
      <guid>https://quiescent.us/2012/05/building-an-interpreter/</guid>
      <description>&lt;p&gt;When I started programming, I thought that compilers where these magic behemoths; Oracles which consumed your source code, and prophesied  the resulting program.  I thought that the compiler was an integral part of the &amp;ldquo;system&amp;rdquo;. I was excited to realize that the compiler is simply another program. A program you can write yourself. You can write a compiler, for your very own language.  Go ahead, make up a language, I&amp;rsquo;ll wait&amp;hellip;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.codestrokes.com/wp-content/uploads/2012/05/hourglass.gif&#34;&gt;&lt;img src=&#34;http://www.codestrokes.com/wp-content/uploads/2012/05/hourglass.gif&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Seriously though, making your own language is a very difficult task, and implementing a language useful enough for non-trivial problems is even more difficult. There is however, a very approachable goal here: Domain Specific Languages (DSLs).  DSLs are focused languages useful to a limited group of people for a limited purpose.&lt;/p&gt;
&lt;p&gt;I like to think of DSLs as tools. For example, sometimes one needs to automate a task, its might be easier to write a small program that helps with that task. But it might be even more useful to write a language that allows you to describe the problem better, then one can write a program using the new language to finish the task in an efficient and repeatable way.  The program has limited usefulness beyond its initial application, but for the application at hand, its perfect. SQL is the canonical example. In this post we&amp;rsquo;ll start with a basic grammar in EBNF. We&amp;rsquo;ll translate that to a flex lexer, and connect that to a bison parser. We&amp;rsquo;ll end up with a syntax tree which we&amp;rsquo;ll execute to calculate a result.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Multicast Delegates in C&#43;&#43;11</title>
      <link>https://quiescent.us/2012/03/multicast-delegates-in-c11/</link>
      <pubDate>Sun, 25 Mar 2012 05:32:43 +0000</pubDate>
      
      <guid>https://quiescent.us/2012/03/multicast-delegates-in-c11/</guid>
      <description>&lt;p&gt;C# has a wonderfully flexible delegate system capable of multicast events.  This simple tool makes event driven software easier to write, and reduces coupling between objects. In 2003 Herb Sutter implemented a general form of the Observer pattern [1].  He called this the multi_function. It uses a mixture of TR1 and boost components to build a multi-cast delegate similar to C#&amp;rsquo;s.  Fast-forward 9 years, and we now have variadic-templates thanks to C++11.  Variadic-Templates allow us to patch a missing component in Sutter&amp;rsquo;s multi_function.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Abstract Syntax Trees: Introduction to Flex</title>
      <link>https://quiescent.us/2012/03/abstract-syntax-trees-introduction-to-flex/</link>
      <pubDate>Sun, 18 Mar 2012 05:36:51 +0000</pubDate>
      
      <guid>https://quiescent.us/2012/03/abstract-syntax-trees-introduction-to-flex/</guid>
      <description>&lt;p&gt;Bison is an incredibly powerful parser generator tool. However most of the examples, and tutorials demonstrate Bison&amp;rsquo;s parsing ability, using on-the-fly computation instead of building a Syntax Tree. Bison is fully capable to generate the front-end of a simple compiler, but to do so, we have to build a syntax tree. Come to find out, building a syntax tree with Bison isn&amp;rsquo;t that difficult, and the key is how one leverages the semantic actions. In this post, we&amp;rsquo;ll look at a basic introduction to bison, then how to build a parse tree for a simple in-fix algebraic statement.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Branching with Mercurial</title>
      <link>https://quiescent.us/2012/02/branching-with-mercurial/</link>
      <pubDate>Mon, 20 Feb 2012 02:18:15 +0000</pubDate>
      
      <guid>https://quiescent.us/2012/02/branching-with-mercurial/</guid>
      <description>&lt;p&gt;Mercurial supports two separate methods for branching. The first is built into how distributed version control functions, in that every clone is a branch itself. This is the branching method Joel Sposky recommends on hginit.com. The second method is called &lt;em&gt;&lt;a href=&#34;http://mercurial.selenic.com/wiki/Branch&#34;&gt;local branches&lt;/a&gt;&lt;/em&gt;. Initially I liked the local branch method; I liked it for the fact that I felt smart for using it. It did not improve productivity. There is a simple reason for this, with local branches it is difficult to diff the branch to the main branch of development e.g. the trunk. This post will walk through local branches, how I used then, and finally, how I quit local branches in favor of a cloning approach.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Compile-Time Polymorphism</title>
      <link>https://quiescent.us/2012/02/compile-time-polymorphism/</link>
      <pubDate>Sun, 05 Feb 2012 21:14:29 +0000</pubDate>
      
      <guid>https://quiescent.us/2012/02/compile-time-polymorphism/</guid>
      <description>&lt;p&gt;Polymorphism is a tool in object orientation, which allows us to model behavior, while simultaneously leverage existing code. Polymorphism allows is behavior reuse.  In C++ polymorphism, comes in 2 flavors, the standard runtime variant, and a curious compile time variant.  Runtime polymorphism, like Java, leverages virtual functions to dynamically bind[1. With virtual functions the compiler doesn&amp;rsquo;t know which method to call until runtime. In C++ this is implemented with the &lt;a href=&#34;http://en.wikipedia.org/wiki/Virtual_method_table&#34;&gt;virtual method table&lt;/a&gt;] a method at the call site. Compile Time polymorphism uses templates, to bind at compile time, thus negating the performance affect of virtual functions.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Parallel Binary Buddy: The Friendly Memory Manager</title>
      <link>https://quiescent.us/2011/11/parallel-binary-buddy-the-friendly-memory-manager/</link>
      <pubDate>Wed, 23 Nov 2011 18:50:20 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/11/parallel-binary-buddy-the-friendly-memory-manager/</guid>
      <description>&lt;p&gt;Fragmentation, the
allocator&amp;rsquo;s sin. Each byte
A buddy, A friend&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Making C&#43;&#43; like Python: The Anderson Smart Pointer Pattern</title>
      <link>https://quiescent.us/2011/10/making-c-like-python-the-anderson-smart-pointer-pattern/</link>
      <pubDate>Sun, 23 Oct 2011 19:00:21 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/10/making-c-like-python-the-anderson-smart-pointer-pattern/</guid>
      <description>&lt;p&gt;Choosing to use C++ brings the additional complexity of memory management.  Dennis Ritchie once stated: The C Programming Language — A language which combines the flexibility of assembly language with the power of assembly language. C++ inherits much of that _flexibility, _however, this &lt;a href=&#34;http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey&#34;&gt;incidental complexity&lt;/a&gt;, can be relegated to a single class, leaving you with the high-level elegance of Python. RAII help with this additional complexity, however without a pattern for guidance implementing RAII consistently can be difficult, defeating the safety it provides.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Parallel Game-of-Life</title>
      <link>https://quiescent.us/2011/10/parallel-game-of-life/</link>
      <pubDate>Sun, 23 Oct 2011 17:55:47 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/10/parallel-game-of-life/</guid>
      <description>&lt;p&gt;Conway&amp;rsquo;s &lt;a href=&#34;http://www.bitstorm.org/gameoflife/&#34;&gt;Game of Life&lt;/a&gt; is a dramatic illustration of emmergent behavior; that a seemingly complex system, such as cell mitosis can be governed by a set of simple rules. OpenMP is a fantastic set of language extensions which allows one to add dramatic parallelism without complex thread management.  As a demonstration of &lt;a href=&#34;http://openmp.org/wp/&#34;&gt;OpenMP&lt;/a&gt;&amp;rsquo;s simplicity I implemented the Game of Life. The code and all analysis is available on &lt;a href=&#34;https://bitbucket.org/jwright/parallel-game-of-life&#34;&gt;bitbucket.org&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>The $1,000,000 Compile</title>
      <link>https://quiescent.us/2011/09/the-1000000-compile/</link>
      <pubDate>Thu, 22 Sep 2011 22:40:42 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/09/the-1000000-compile/</guid>
      <description>&lt;p&gt;Hitting the compile and run button costs $1,000,000. How would such a cost affect your test strategy? As extreme as that sounds, its a harsh reality for ASIC designers. The start-up costs for an ASIC design are extreme, as a result ASIC verification is very important. Especially since you can&amp;rsquo;t just update a buggy ASIC.  In software engineering, we design increasingly complex systems requiring more and more elegant test strategies.  I propose ASIC verification is in a more mature state, and software engineers could learn a lot from the translation of these techniques.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Good Tools, Excellent Results</title>
      <link>https://quiescent.us/2011/08/good-tools-excellent-results/</link>
      <pubDate>Sun, 21 Aug 2011 07:23:25 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/08/good-tools-excellent-results/</guid>
      <description>&lt;p&gt;This semester for the C++ practicum we are building a clone of Zork.  Like many games of the genre, Zork is driven by a database.  Our implementation is a JSON database.  I chose JSON for a few reasons, but most importantly because its a human readable format that&amp;rsquo;s simple to understand.  I started by editing JSON files by hand in a text editor, however I found very quickly that investigating in a quick tool greatly improved my quality.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Why do some tutorials use std::cout and others use just cout?</title>
      <link>https://quiescent.us/2011/08/why-do-some-tutorials-use-stdcout-and-others-use-just-cout/</link>
      <pubDate>Fri, 19 Aug 2011 16:55:56 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/08/why-do-some-tutorials-use-stdcout-and-others-use-just-cout/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Hijacking System Programs</title>
      <link>https://quiescent.us/2011/08/hijacking-system-programs/</link>
      <pubDate>Fri, 12 Aug 2011 06:00:18 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/08/hijacking-system-programs/</guid>
      <description>&lt;p&gt;Let&amp;rsquo;s say for a moment that you are a graduate student, with shell access to your schools server. The server maintains a number of tools you need for classes, and research.  All is well, except the stock editor on the server is wicked old.  Like an eternity old.  Well that happened to me. I am fully addicted to &lt;a href=&#34;https://bitbucket.org/jwright/vim-configuration&#34;&gt;my custom vim configuration&lt;/a&gt;, but it requires vim7.3.  My school&amp;rsquo;s server only has 7.0.  So, how does one install their own application with root privledges?  You create a private root.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Version Control More Than Collaboration</title>
      <link>https://quiescent.us/2011/07/version-control-more-than-collaboration/</link>
      <pubDate>Wed, 06 Jul 2011 05:18:48 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/07/version-control-more-than-collaboration/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve used version control in some form or another since I was a freshman in college, however I&amp;rsquo;m quite the anomaly.  I will use a tool fully knowing that its more than I need, just to learn something new.  Initially, this is how I approached version control. Except for a few unique situations version control of my homework, seemed like more work than it was worth.  I used to think version control was merely a collaboration tool for teams of people.  I couldn&amp;rsquo;t have been more wrong.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Game Framework for C&#43;&#43; Practicum</title>
      <link>https://quiescent.us/2011/06/game-framework-for-c-practicum/</link>
      <pubDate>Sat, 25 Jun 2011 22:37:51 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/06/game-framework-for-c-practicum/</guid>
      <description>For this year&amp;rsquo;s C++ practicum, we are going to build a small game engine. I&amp;rsquo;m keeping the code on bitbucket: http://bitbucket.org/jwright/gamecomponents Join us, or fork the code and make your own design. I look forward to seeing how this progresses.</description>
    </item>
    
    <item>
      <title>Being Truely Productive</title>
      <link>https://quiescent.us/2011/06/being-truely-productive/</link>
      <pubDate>Sun, 19 Jun 2011 18:59:47 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/06/being-truely-productive/</guid>
      <description>&lt;p&gt;Productivity is an elusive mistress.  I approach productivity much like any design problem. I lay out my requirements, and I iterate until I am happy with the outcome. Over the last few years I have spent a lot time laying out my design process.  Along the way I found a number of tools that were helpful.  This is my personal process and while I think it&amp;rsquo;s a great process.  It&amp;rsquo;s important to refactor for yourself. The key to my productivity is consistency. I work well with a defined workflow. Lastly, interruptions are a certainty, so one must find a way to make context switches less disruptive.&lt;/p&gt;
&lt;blockquote&gt;Try to setup natural stopping points in your process. You will be interrupted so make context switches cheap.&lt;/blockquote&gt;
&lt;p&gt;Consistency &lt;em&gt;is&lt;/em&gt; my process, and tools help me deal with strict and dynamic constraints.  I use a number of tools help me be productive, yet consistency is the most powerful function for me.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Overview of Upcoming Articles</title>
      <link>https://quiescent.us/2011/06/overview-of-upcoming-articles/</link>
      <pubDate>Thu, 16 Jun 2011 19:51:14 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/06/overview-of-upcoming-articles/</guid>
      <description>I&amp;rsquo;ve been putting quite a bit of time into this semester&amp;rsquo;s upcoming C++ Practicum at ASU. I&amp;rsquo;m currently working on an article on Skip-Lists in D, and a few other C++ orientated articles. Expect a new post Sunday night. &amp;rsquo;til then, thank you for your patience, cheers.</description>
    </item>
    
    <item>
      <title>Type-Safe Variable Argument Lists</title>
      <link>https://quiescent.us/2011/06/type-safe-variable-argument-lists/</link>
      <pubDate>Mon, 06 Jun 2011 06:59:00 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/06/type-safe-variable-argument-lists/</guid>
      <description>&lt;p&gt;Type-safety is a popular topic. Perceived as a panacea for bad software, the Department of Defense implemented Ada.  The original thought was restriction synonymous with robustness. From this, opponents claim type safe languages place the programmer’s hands in handcuffs, thereby thwarting generic code. Modern languages, such as D, and Java leverage a statically checked type system with a focus on consistency, not restriction.  Modern type systems abet generic code, without sacrificing robustness.  Today, there seems to be a general trend toward strong typing.  Personally, I try to leverage the type system as a tool to ensure correct code.&lt;/p&gt;
&lt;blockquote&gt;D is a powerful  language, that statically checks code correctness via a strong type system, yet still offers flexible constructs.&lt;/blockquote&gt;
&lt;p&gt;D’s focus of code correctness, provides a strong type system, in a manner conducive to generic code.  D’s type-safe variable argument list is an example of this.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Parallelism in D</title>
      <link>https://quiescent.us/2011/05/parallelism-in-d-bucket-sort-part-2/</link>
      <pubDate>Sun, 29 May 2011 18:02:24 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/05/parallelism-in-d-bucket-sort-part-2/</guid>
      <description>&lt;p&gt;Parallelism, it sounds like a religion, and in some sense it is. Like many facets of software engineering, writing good parallel code is more of an art than a science.  I come from a FPGA background where parallelism is part of the language; part of the culture! The tools are designed to find deadlocks, analyze timing and the language itself is fully aware of parallelism.  The hardware world understands parallelism, yet writing parallel software is still difficult.  D is making some pioneering steps in the right direction for &lt;a href=&#34;http://www.digitalmars.com/d/2.0/phobos/std_parallelism.html&#34;&gt;parallelism&lt;/a&gt;.  I use a parallel implementation of bucket sort to show how D makes writing parallel code, correct.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Bucket Sort</title>
      <link>https://quiescent.us/2011/05/bucket-sort/</link>
      <pubDate>Tue, 24 May 2011 04:59:59 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/05/bucket-sort/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://bitbucket.org/jwright/bucket-sort/overview&#34;&gt;D Source Code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Sorting is a very important operation in computer programs. Knuth devotes an entire chapter to sorting and search. Sorting algorithms, like most algorithms, use the &lt;a href=&#34;http://en.wikipedia.org/wiki/Big_Oh_notation&#34;&gt;Big O notation&lt;/a&gt; to compare &lt;a href=&#34;http://en.wikipedia.org/wiki/Computational_complexity_theory&#34;&gt;computational complexity&lt;/a&gt;.  &lt;a href=&#34;http://en.wikipedia.org/wiki/Bucket_sort&#34;&gt;Bucket sort&lt;/a&gt; is one such sorting algorithm.  however bucket sort typically doesn’t actually sort the array.  In the normal case, bucket sort is used to partition the data set into groups, or buckets.  Each bucket is then sorted using a separate algorithm such as quicksort, or insertion sort.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>D for the C&#43;&#43; Programmer</title>
      <link>https://quiescent.us/series/the-red-black-tree/d-for-the-c-programmer-red-black-tree-part-3/</link>
      <pubDate>Wed, 18 May 2011 03:06:36 +0000</pubDate>
      
      <guid>https://quiescent.us/series/the-red-black-tree/d-for-the-c-programmer-red-black-tree-part-3/</guid>
      <description>&lt;p&gt;As a comparative study, I am porting a Red-Black Tree from C++ to the &lt;a href=&#34;http://www.digitalmars.com/d/2.0/dmd-linux.html&#34;&gt;D programming language&lt;/a&gt; (&lt;a href=&#34;http://www.codestrokes.com/archives/59&#34;&gt;Part 1&lt;/a&gt;, &lt;a href=&#34;http://www.codestrokes.com/archives/83&#34;&gt;Part 2&lt;/a&gt;). Overall D is an easy, practical transition for the C++ programmer. D provides a number of features for implementing correct code, however it is D’s simplicity that makes it truly enticing as a replacement. While D retains _C Style Syntax, _it is considerably simpler than C++, especially in the presence of exceptions.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Class Invariants</title>
      <link>https://quiescent.us/series/the-red-black-tree/class-invariants-red-black-tree-part-2/</link>
      <pubDate>Fri, 13 May 2011 02:40:48 +0000</pubDate>
      
      <guid>https://quiescent.us/series/the-red-black-tree/class-invariants-red-black-tree-part-2/</guid>
      <description>&lt;p&gt;This week, I started porting my &lt;a href=&#34;http://www.codestrokes.com/archives/59&#34;&gt;C++ implementation&lt;/a&gt; of the Red-Black tree to D.  I am trying to pay special attention to the features of D, intended to make writing correct code easier. While on that vane,  I was reading an excellent &lt;a href=&#34;http://reprog.wordpress.com/2010/04/25/writing-correct-code-part-1-invariants-binary-search-part-4a/&#34;&gt;article&lt;/a&gt;, discussing invariants, and I was pleased to find such a useful implementation of the &lt;a href=&#34;http://www.digitalmars.com/d/2.0/class.html#Invariant&#34;&gt;class invariant&lt;/a&gt; in the D language.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>The Red-Black Tree</title>
      <link>https://quiescent.us/series/the-red-black-tree/the-red-black-tree-part-1/</link>
      <pubDate>Mon, 09 May 2011 06:59:01 +0000</pubDate>
      
      <guid>https://quiescent.us/series/the-red-black-tree/the-red-black-tree-part-1/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://bitbucket.org/jwright/cse310-red-black-tree/overview&#34;&gt;C++ Source Code&lt;/a&gt;
&lt;a href=&#34;https://bitbucket.org/jwright/red-black-tree-d&#34;&gt;D Source Code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;D provides a number of features that simplify designing software, especially in the embedded environment.  I will show in this 2 part comparison, between C++ and D, that D helps one write &lt;strong&gt;correct code&lt;/strong&gt;.  Correct code is something &lt;a href=&#34;http://erdani.com/&#34;&gt;Andrei Alexandrescu&lt;/a&gt;, stresses heavily as a prominent feature of D.   I use the Red-Black Tree for such a comparison since its complicated enough to make memory management difficult, while retaining real-world application.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java 4K Contest</title>
      <link>https://quiescent.us/2011/05/java-4k-contest/</link>
      <pubDate>Sat, 07 May 2011 22:10:54 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/05/java-4k-contest/</guid>
      <description>Crazy challenging game contest: http://javaunlimited.net/contests/java4k.php Reminds me of the winners of a 96KB contest: http://en.wikipedia.org/wiki/.kkrieger</description>
    </item>
    
    <item>
      <title>Thing a Week: Algorithm Edition</title>
      <link>https://quiescent.us/2011/05/thing-a-week-algorithm-edition/</link>
      <pubDate>Tue, 03 May 2011 23:37:37 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/05/thing-a-week-algorithm-edition/</guid>
      <description>In homage to Jonathan Coulton, this summer I intend to explore a series of algorithms in an effort to both learn the D programming language, as well as deepen my computer science background. First up, the Red-Black Tree.</description>
    </item>
    
    <item>
      <title>Welcome to Code Strokes</title>
      <link>https://quiescent.us/2011/02/hello-world/</link>
      <pubDate>Fri, 11 Feb 2011 02:37:45 +0000</pubDate>
      
      <guid>https://quiescent.us/2011/02/hello-world/</guid>
      <description>Welcome to Code Strokes. Our focus here is about elegant software design. We attempt to meld the worlds of deeply embedded real-time software, with modern software design principles. Take a look at our features. If you have any feedback leave a comment. Thank you, and welcome.</description>
    </item>
    
  </channel>
</rss>
