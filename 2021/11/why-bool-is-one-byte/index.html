<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <meta name="generator" content="Hugo 0.100.2" />

  
  <meta name="description" content="Some description">
  

  
  <link rel="apple-touch-icon" sizes="180x180" href="https://quiescent.us/apple-touch-icon.png">

  
  <link rel="icon" type="image/png" sizes="32x32" href="https://quiescent.us/favicon-32x32.png">

  
  <link rel="icon" type="image/png" sizes="16x16" href="https://quiescent.us/favicon-16x16.png">

  
  <link rel="manifest" href="https://quiescent.us/site.webmanifest">

  
  <link rel="mask-icon" href="https://quiescent.us/safari-pinned-tab.svg" color="#5bbad5">

  <meta name="msapplication-TileColor" content="#da532c">

  <meta name="theme-color" content="#ffffff">

  
  <link rel="stylesheet" href="https://quiescent.us/css/bootstrap.min.css" />

  
  <link rel="stylesheet" href="https://quiescent.us/css/syntax.css" />
  
  
  <title>Why is bool one byte: Wasting space to save time | The Quiescent Current</title>
  

  <style>
body {
  min-width: 300px;
}

.custom-navbar {
  margin-bottom: 1em;
  height: 60px;
}

.custom-navbar a {
  display: inline-block; 
  padding: 18px 0;
  margin-right: 1em; 
  font-weight: bold; 
}

.custom-navbar a:hover,
.custom-navbar a:focus {
  text-decoration: none; 
}

@media print {
  .custom-navbar {
    display: none;
  }
}

article {
  padding-bottom: 1em;
}

img {
  max-width: 100%;
}


body {
  background-color: #fff;
}



body {
  color: #212529;
}



a {
  color: #007bff;
}



a:hover,
a:focus {
  color: #0056b3;
}



.custom-navbar {
  background-color: #212529;
}



.custom-navbar a {
  color: rgba(255, 255, 255, 0.75);
}



.custom-navbar a:hover,
.custom-navbar a:focus {
  color: rgba(255, 255, 255, 1);
}



.container {
  max-width: 800px;
}



pre {
  display: block;
  padding: 9.5px;
  word-break: break-all;
  word-wrap: break-word;
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
}

pre code {
  padding: 0;
  font-size: inherit;
  color: inherit; 
  white-space: pre-wrap;
  background-color: transparent;
  border: none;
  border-radius: 0;
}

code {
  padding: 2px 4px;
  color: inherit; 
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: .9em;
}



blockquote,
.blockquote {
  padding: 10px 20px;
  margin: 0 0 20px;
  font-size: 1em;
  border-left: 5px solid #6c757d;
}

</style>
</head>

<body>
  <nav class="custom-navbar">
  <div class="container">
    
    <a href="/posts">Posts</a>
    
    <a href="/series">Series</a>
    
    <a href="/tags">Tags</a>
    
    <a href="/about">About</a>
    
  </div>
</nav>
  
  <div class="container">
    <article>
      <h1>Why is bool one byte: Wasting space to save time</h1>
<p>Boolean carries 1 bit of information. The canonical example of binary, On/Off,
True/False. Yet, the bool type in C and C++ is 1 byte large, 8 bits of
information. Carrying thus $$2^8 = 256$$ representable values. This may not sound like much, but consider an array of bools (a common misunderstanding beginning C++ students make trying to formulate a bit-field): <code>bool fatBitField[8]</code></p>
<p>This <em>wasted</em> space however has a useful purpose. It a common reason in many optimizations we make in data structures, we trade space for time. In this instance we&rsquo;re trading space for a hardware design principle, addressable memory.</p>
<!-- more -->
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="n">fatBitField</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%lu</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>           <span class="c1">// prints 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%lu</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fatBitField</span><span class="p">));</span> <span class="c1">// prints 8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Outputs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">➜  clang -std<span class="o">=</span>c11 byte.c
</span></span><span class="line"><span class="cl">➜  ./a.out
</span></span><span class="line"><span class="cl"><span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="m">8</span>
</span></span></code></pre></div><p>x86 based machines and most microprocessors except for some uniquely specialized Digital Signal Processors (DSPs) <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> byte addressable. Thus if you wanted to make a bit-field, to pack bools as tight as possible, how would you do so?</p>
<p>How do you mutate a single bit in C?</p>
<h2 id="simple-bool">Simple Bool</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="n">anInt</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">anInt</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Plug this into <a href="">Compiler Explorer</a></p>
<span class="image-container"><span class="link" ><a href="/img/bit-bool/simple-bit-bool.png" 
        target="_blank"><img class="img" src="/img/bit-bool/simple-bit-bool.png"/></a></span><span class="caption">
            <span class="title">Compiler Explorer Simple Bool</span class="image-container-caption">
        </span>
</span>
<p>We can see the source lines 5, and 6 correspond to just two instructions, lines 6 and 7 in in the output assembly.</p>
<p>Let&rsquo;s compare this, the simplest case to manual bit masking</p>
<h1 id="manual-bit-masking">Manual Bit Masking</h1>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">anInt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">anInt</span> <span class="o">=</span> <span class="n">anInt</span> <span class="o">^</span> <span class="mi">0</span><span class="n">b1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Outputs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">➜  clang -std<span class="o">=</span>c11 bitmask.c <span class="c1"># Add a printf to get output. Leave it out to get simpler assembly</span>
</span></span><span class="line"><span class="cl">➜  ./a.out
</span></span><span class="line"><span class="cl"><span class="m">2</span>
</span></span></code></pre></div><p>Again inspect the assembly with Compiler Explorer<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>
<span class="image-container"><span class="link" ><a href="/img/bit-bool/bit-mask.png" 
        target="_blank"><img class="img" src="/img/bit-bool/bit-mask.png"/></a></span><span class="caption">
            <span class="title">Compiler Explorer Bit Mask</span class="image-container-caption">
        </span>
</span></p>
<p>Notice again how simple the instructions are. The corresponding mutation (grey lines) are short and single instruction. Now let&rsquo;s try to make a fully packed bool, using all 8 bits independently addressable.</p>
<h1 id="c-bitfields-and-unions-to-preserve-space">C BitFields and Unions to preserve space</h1>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#pragma pack(1)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_bitfield</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="nl">one</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="nl">two</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="nl">three</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="nl">four</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="nl">five</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="nl">six</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="nl">seven</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="nl">eight</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">bitfield</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">union</span> <span class="n">_asInt</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">asInt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">bitfield</span> <span class="n">asField</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">BitFieldAsInt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">BitFieldAsInt</span> <span class="n">field</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">field</span><span class="p">.</span><span class="n">asInt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">field</span><span class="p">.</span><span class="n">asField</span><span class="p">.</span><span class="n">two</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//printf(&#34;%X\n&#34;, field.asInt);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Again compare in compiler explorer
<span class="image-container"><span class="link" ><a href="/img/bit-bool/fully-packed.png" 
        target="_blank"><img class="img" src="/img/bit-bool/fully-packed.png"/></a></span><span class="caption">
            <span class="title">Compiler Explorer Fully Packed bitfield</span class="image-container-caption">
        </span>
</span></p>
<p>Notice the source line 8. Here you can see it or&rsquo;s a 2.  This is the compiler recognizing we are trying to mutate a single bit. We did an assignment and the compiler changed this to an <code>or</code> instruction. However, even though the compiler recognized our assignment can be implemented as an <code>or</code>, it still takes three instructions to do the same and the previous examples. Thus by trying to save space, we are causing the CPU to work more performing extra instructions.</p>
<h1 id="well-why-isnt-the-computer-bit-addressable-then">Well, why isn&rsquo;t the computer bit addressable then?</h1>
<p>The short answer, bit access isn&rsquo;t that common, thus the hardware is optimized for the more common access of bytes. Although due to various levels of cache and the time required to pull objects from different levels of the memory hierarchy (e.g. CPU caches, Main Memory, Durable Storage, Network, etc), multiple blocks of memory are pulled at a time.</p>
<p>A related question is &ldquo;what does 64-bit computing mean?&rdquo;</p>
<span class="image-container"><span class="link" ><a href="/img/bit-bool/64bit-meme.jpg" 
        target="_blank"><img class="img" src="/img/bit-bool/64bit-meme.jpg"/></a></span><span class="caption">
            <span class="title">64-bit Compute Meme</span class="image-container-caption">
        </span>
</span>
<p>The more detailed answer comes from understanding that 64-bit computing means.</p>
<p>Now consider that bool by default stored only 1 bit (instead of a byte). The apocryphal story of &ldquo;&hellip;640KB is enough for everybody&hellip;&rdquo;<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup> is also related to this point&hellip;addressable memory.</p>
<p>You may remember when 32-bit addresses were common. Before that computers were 16-bit and even 8-bit addressable. Many microcontrollers (the things that make your fridge and oven work) are still 8-bit. It&rsquo;s all that needed for those use cases. What this means that given an memory address, how many bytes will be pulled from main memory? This is a hardware level concept. Literally there are ~64 individual wires on the board. These wires signal a stream of bits <code>0b0111010101...</code> to the RAM. The RAM returns the values represented by that address.</p>
<blockquote>
<p>Thus, the maximum amount of addressable memory is bounded by the size of the address. In 32 bits, this was 4GB.</p>
</blockquote>
<p>$$2^{32} = 4294967296$$
$$ 4294967296 / 2^{30} = 4 GB $$</p>
<p>In 64 bits,
$$2^{64} = 18446744073709551615 bytes$$
$$2^{64} / 2^{50} = 16384 Petabytes $$</p>
<p>If instead we decided that each address represented a single bit, in order to get even 4 GB from our 32-bit computing days we&rsquo;d need CPUs with  35-bit computers</p>
<p>$$ (2^{35} / 8) / 2^{30} = 4GB $$</p>
<p>Thus making a bit addressable memory, requires more hardware. However are those resources worthwhile? It&rsquo;s all about access patterns. How is most memory utilized? Again it largely depends on the domain, which is why some processors have special addressing modes. However on most computing, we want to fetch large blocks of time to amortize the cost of fetching from the next level in the memory cache. &ldquo;Paying&rdquo; the time to fetch from the next physical location with wasteful for single bits.</p>
<h1 id="references">References</h1>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>Microchip. <em>dsPIC33F/PIC24H Data Memory</em>. <a href="http://ww1.microchip.com/downloads/en/DeviceDoc/70202C.pdf">http://ww1.microchip.com/downloads/en/DeviceDoc/70202C.pdf</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>You can generate the assembly yourself with your own compiler using the <code>-S</code> option <code>➜  clang -std=c11 -S bitmask.c</code>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>Katz, Jon. <em>Did Gates Really Say 640K is Enough For Anyone?</em> <a href="https://www.wired.com/1997/01/did-gates-really-say-640k-is-enough-for-anyone/">https://www.wired.com/1997/01/did-gates-really-say-640k-is-enough-for-anyone/</a>&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

    </article>
  </div>

  
  
  
  <script>
  window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
  ga('create', 'UA-168773592-1', 'auto');
  ga('send', 'pageview');
  </script>
  <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  

  
<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.css" />
<script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#216942",
      "text": "#b2d192"
    },
    "button": {
      "background": "#afed71"
    }
  }
})});
</script>

</body>

</html>
