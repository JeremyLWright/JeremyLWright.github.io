<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Property Driven Design on QE</title>
    <link>https://quiescent.us/series/property-driven-design/</link>
    <description>Recent content in Property Driven Design on QE</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 05 Jul 2015 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://quiescent.us/series/property-driven-design/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Property Driven Design: MinMax</title>
      <link>https://quiescent.us/2015/07/property_driven_design_minmax/</link>
      <pubDate>Sun, 05 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://quiescent.us/2015/07/property_driven_design_minmax/</guid>
      <description>&lt;p&gt;I wrote an article on &lt;a href=&#34;http://www.codestrokes.com/2014/09/property-testing-in-c/&#34;&gt;Property Testing&lt;/a&gt;
about a year ago. Isocpp.org even &lt;a href=&#34;https://isocpp.org/blog/2014/12/property-testing&#34;&gt;linked to
it&lt;/a&gt; which was pretty cool.
Recently, I uncovered a fantastic talk by &lt;a href=&#34;https://www.youtube.com/watch?v=shngiiBfD80&#34;&gt;Jessica Kerr about property
testing&lt;/a&gt;. Kerr&amp;rsquo;s talk
reinvigorated my languid research effort toward generated testing. Kerr
presented the idea (novel to me) that properties aren&amp;rsquo;t rigid. Properties
don&amp;rsquo;t need to exclude all possible incorrect results for a given function.
Properties simply must &lt;em&gt;reduce the size&lt;/em&gt; of the incorrect space. This may seem
like semantics, but it is easier to exclude a wild-ass-guess that verify it is correct.
Additionally, some domains may not have a solidly defined answer,a nd the
result my be probabilistic in nature. This post will focus on deterministic
problems for the moment, but realize that property testing is vastly more
general than mundane example testing. How properties reduce the size of the
problem space makes me imagine this Figure.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://quiescent.us/img/Properties_solution_space.png&#34; alt=&#34;sometimes_code_gives_you_a_wtf&#34;&gt;&lt;/p&gt;
&lt;p&gt;Following Kerr&amp;rsquo;s references, I found a set of projects from a &lt;a href=&#34;http://www.cs.ou.edu/~rlpage/SEcollab/20projects/&#34;&gt;predicate-logic
course&lt;/a&gt;. This course
provides 20 separate projects excellently cast for a property-driven-design
tutorial. These projects are unique since besides the typical requirements
they enumerate the predicate functions each requirement typifies. Predicate
functions are to a predicate-logician as properties are to a computer
scientist. These enumerated properties (predicates) clarified
many points I misunderstood about property testing.&lt;/p&gt;
&lt;p&gt;This post will step through the design of the first project
&lt;a href=&#34;http://www.cs.ou.edu/~rlpage/SEcollab/20projects/minmax.htm&#34;&gt;minmax&lt;/a&gt; using
C++. My primary goal for this article is to address a concern raised by
a colleague, &amp;ldquo;Does pulling in more complexity — a fancy test
generator — actually increase quality?&amp;rdquo;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/JeremyLWright/property_driven_design/tree/master/01_minmax&#34;&gt;Code for this article&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/JeremyLWright/JeremyLWright.github.io/commits/content/content/posts/2015-07-05-property_driven_design_minmax.markdown&#34;&gt;Revision Log for this article&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>