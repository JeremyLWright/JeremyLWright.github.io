<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>System on Code Strokes</title>
    <link>http://codestrokes.com/categories/system/</link>
    <description>Recent content in System on Code Strokes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 18 Sep 2012 23:11:51 +0000</lastBuildDate>
    <atom:link href="http://codestrokes.com/categories/system/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Abstraction in Plain English</title>
      <link>http://codestrokes.com/2012/09/abstraction-in-plain-english/</link>
      <pubDate>Tue, 18 Sep 2012 23:11:51 +0000</pubDate>
      
      <guid>http://codestrokes.com/2012/09/abstraction-in-plain-english/</guid>
      <description>&lt;p&gt;Abstraction is an interesting concept. For me personally, abstraction was never clearly explained. I left school and entered my first job knowing I should abstract things, but I realize now my understanding of abstraction amounted to obscurity.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;Abstraction to me meant, “Don’t use that thing directly, &lt;em&gt;abstract it&lt;/em&gt; and use some interface instead.&amp;rdquo; &amp;ldquo;That’s what &lt;em&gt;good&lt;/em&gt; programmers do,&amp;rdquo; I told myself. I taught myself a lot about function pointers, and advanced OO techniques using pure virtual classes all to avoid using something directly. This is wrong. My entire prespective on abstraction was wrong. A few days ago I was watching a &lt;a href=&#34;http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup-Cpp11-Style&#34;&gt;lecture from Bjarne Stroustrup&lt;/a&gt;, comically, one I’ve watch before and it finally clicked.&lt;/p&gt;

&lt;blockquote&gt;Express notions as the expert in the field understands them. — Bjarne Stroustroup.&lt;/blockquote&gt;

&lt;p&gt;Wow, that is simple. Abstraction is not about creating layers or separating the programmer from anything, in fact abstraction has nothing to do with the programmer at all. Abstraction is about creating entities, may they be objects, functions or simply variables which describe the system as an expert would describe the system.&lt;/p&gt;

&lt;p&gt;For example think of building a blackjack game. In blackjack the dealer is our expert, so we need to describe the objects in our system in a vernacular which makes sense to her. First, let us describe a bad example of abstraction with respect to the deck used for dealing cards to the players. This bad example starts with the programmer’s perspective. To a programmer, a deck looks like an array. We’ve been taught that it is not good to allocate a bunch of memory into an array so we hold an array of pointers to cards which are allocated in the heap. Okay so now we have a container to hold the cards std::vector&lt;Card*&gt;. For this article lets ignore the ownership issues, and continue.&lt;/p&gt;

&lt;p&gt;What does dealing look like? Oh that’s simple, just index over the vector to give a pointer of each card to the Player.  Your code might look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void DealCardsToPlayer(size_t cards_to_deal, Player* p)
{
    for(int i = 0; i &amp;lt; cards_to_deal; ++i)
    {
        p-&amp;gt;AcceptCard(deck.back()); //deal from back, because dealing from front will invalidate pointers...
        deck.pop_back();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now try to explain to an actual dealer what this code is doing. Firstly, you&amp;rsquo;ll never be able to justify dealing from the back of the deck, &lt;a href=&#34;http://en.wikipedia.org/wiki/Cheating_(casino&#34;&gt;its cheating&lt;/a&gt;). The problem here isn&amp;rsquo;t functional. The code will probably work. the problem is perspective. Lets reevaluate this from a dealer&amp;rsquo;s perspective. A dealer has a box, called the Shoe. In the shoe are all the decks. The dealer draws from the Shoe, and give the card to the player. With the dealer’s perspective in mind the code might look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void DealInitialHand(Player* p)
{
    //The rules of blackjack are defined there is no reason to make this code
    //more complex than this. The Initial hand consists of 2 cards. period.
    p-&amp;gt;AcceptCard(Shoe-&amp;gt;DrawCard());
    p-&amp;gt;AcceptCard(Shoe-&amp;gt;DrawCard());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice we didn&amp;rsquo;t use a loop. There&amp;rsquo;s no reason to abstract the number of cards being dealt. The runs of blackjack are known. Is is actually an conscience decision. In Software Product Lines, this opportunity is called a variation point. It is a single point in the software where one could offer differing behavior. However, offering differing behavior is a game with defined rules is cheating. Thus unless there are other requirements to implement a variation point, keep it simple.&lt;/p&gt;

&lt;p&gt;Functionally the code does the same thing. After either function call, the Player has 2 cards in their hand and dealer’s deck has 2 fewer cards. The difference is the perspective. The program should always follow the perspective of the “expert in the field”. There is a reason experts, in any field, have a specialized language, and specialized methods. For the most part, the principles and practices are worked out over a great deal of time to define the most efficient and accurate way to convey information.&lt;/p&gt;

&lt;p&gt;As a programmer, steal that knowledge. Leverage all the work someone else did already, and just use the vernacular that field leverages. Doing so will make your code more readable, your programs more accurate. Furthermore, the maintenance on a system is easier. If you ever have to call an expert in to consult for the project, you’ll have objects and call flows which model the expert’s thought process. You’ll get a better response from your expert.&lt;/p&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.artima.com/intv/abstreffi.html&#34;&gt;http://www.artima.com/intv/abstreffi.html&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.artima.com/intv/modern.html&#34;&gt;http://www.artima.com/intv/modern.html&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.artima.com/intv/goldilocks.html&#34;&gt;http://www.artima.com/intv/goldilocks.html&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>The Importance of System Design</title>
      <link>http://codestrokes.com/2012/07/the-importance-of-system-design/</link>
      <pubDate>Sun, 15 Jul 2012 17:00:44 +0000</pubDate>
      
      <guid>http://codestrokes.com/2012/07/the-importance-of-system-design/</guid>
      <description>&lt;p&gt;For the small programs we tend to implement as part of a semester project, or the simple &amp;ldquo;one-off/get-it-done&amp;rdquo; programs at work, system design rarely plays a part. However, even in the smallest problems a top-level system design is critical for consistency and ease of use. Class components, regardless of how precise and accurate they are in their own internal design, if they aren&amp;rsquo;t externally consistent with other objects, the system will be brittle, and difficult to use.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;In a recent project, I used a bottom-up approach. I designed each class in isolation. I was very diligent to define the ownership semantics, and use each smart pointer and r-value reference type correctly. Despite all the time spent on the details of each object, when I tried to use the objects together, their interfaces were so inconsistent the individual objects were unusable. Case in point:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(auto playersHand : player)
{
    if(playersHand-&amp;gt;Value() &amp;gt; dealersHand-&amp;gt;Value())
    {
        player.Win(*playersHand-&amp;gt;GetBet().get()); //&amp;lt;-- This is a red-flag
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you have to retrieve the raw pointer from the smart_pointer container, you are doing something wrong.&lt;/p&gt;

&lt;p&gt;Here the Player wants a reference to the winning Bet. The player doesn&amp;rsquo;t own the bet, nor does it modify it, it just wants a reference, so I used the &lt;em&gt;passing by const-to-reference&lt;/em&gt; idiom. The Hand however shares a reference between the Table, and the Player. So I used a shared_ptr&lt;Bet&gt;.  shared_ptr implies that it owns and entirely manages the underlying pointer. Smart pointers can reduce or eliminate raw pointers in your system, making it safer. Fetching the raw pointer from such a container invites even bigger problems than managing the raw pointer yourself. Now you have two entities claiming ownership of a raw pointer. This is a fast way to a double-delete problem or more likely a memory leak.&lt;/p&gt;

&lt;p&gt;C++11 contains a powerful number of tools to allow more general components in our designs. This is however, a two-edge sword. Generic components are great. They enable tested code to be reused across multiple projects. This alone improve quality, and reduces time-to-market. Derisking our projects is a very positive thing, and we should continue doing so.&lt;/p&gt;

&lt;blockquote&gt;Time-to-market is an important metric for academic projects as well. Reducing time-to-market, derisks your ability to complete the project before the due date. This allows you to tackle a more ambitious solution...&lt;/blockquote&gt;

&lt;p&gt;C++11&amp;rsquo;s generalization tools also allow code to be more easily refactored. Take for instance the following C++98 code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; for(vector&amp;lt;shared_ptr &amp;gt;::iterator player = players_.begin(); 
    player != players_.end();
    ++player)
{
    for(vector&amp;lt;shared_ptr &amp;gt;::iterator playersHand = player.begin();
            playersHand != player.end();
            ++playersHand)
    {
        /** ... Other Code Here ... */
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compared to the equivalent C++11 code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(auto player : players_)
{
    for(auto playersHand : player)
    {
        /** ... Other Code Here ... */
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, typedefs can help here, but the C++11 version is still far more general. There are no types explicitly called out in the for loops. This is immensely powerful. It allows one to change the underlying container in each type, and the for loop simply iterates over the new type. This makes refactoring easier, but making the code more general also makes a system design more important than ever. As our code becomes more general its more important that types behave consistantly. For example, look at the C++98 version above. By looking at the iterator declaration, we know that we&amp;rsquo;re iterating over a shared pointer, ergo we&amp;rsquo;ll use the -&amp;gt; operator. However in the C++11 version we have no idea what type player is. Its declared with auto, and fed by our user defined type. Where C++98 used declarations to state the interface, C++11 requires consistency.&lt;/p&gt;

&lt;p&gt;Within a program, the designer must make broad statements over the objects&amp;rsquo; behavior. If all objects within a system behave the same, then the users of those components can expect a certain level consistency. It becomes clear which use cases of an object are correct and which are not. This follows from Joel Spolsky&amp;rsquo;s idiom &lt;a href=&#34;http://www.joelonsoftware.com/articles/Wrong.html&#34;&gt;Make Wrong Code Look Wrong&lt;/a&gt;.  The compiler can tell us we are using the wrong operator, but this is a sign that we&amp;rsquo;re lacking a consistent interface with our objects. Notice however that the compiler cannot tell us if we are using the object in a semantically incorrect way. Just because it compiles, doesn&amp;rsquo;t mean its right. Scott Meyers puts this as: &amp;ldquo;Make interfaces easy to use correctly and hard to use incorrectly.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Use the new generalization tools in C++11. It will make your code better. Our programs have always needed a system-design; it&amp;rsquo;s simply more apparent now. C++11 enables you to make better quality systems by forcing consistency across your objects and simultaneously making your code more general &lt;a href=&#34;http://tirania.org/blog/archive/2012/Apr-04.html&#34;&gt;without sacrificing performance&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>