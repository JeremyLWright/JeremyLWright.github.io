<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Productivity on Code Strokes</title>
    <link>http://codestrokes.com/categories/productivity/</link>
    <description>Recent content in Productivity on Code Strokes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 24 Nov 2013 22:14:50 +0000</lastBuildDate>
    <atom:link href="http://codestrokes.com/categories/productivity/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Sean Parent: No Raw Loops</title>
      <link>http://codestrokes.com/2013/11/sean-parent-no-raw-loops/</link>
      <pubDate>Sun, 24 Nov 2013 22:14:50 +0000</pubDate>
      
      <guid>http://codestrokes.com/2013/11/sean-parent-no-raw-loops/</guid>
      <description>&lt;p&gt;A group of colleagues and I watched Sean Parent&amp;rsquo;s Going Native Talk on &amp;ldquo;&lt;a href=&#34;http://channel9.msdn.com/Events/GoingNative/2013/Cpp-Seasoning&#34;&gt;C++ Seasoning&lt;/a&gt;&amp;rdquo;. Parent takes some extreme views on how to use C++, but his examples for using the STL to simplify code are phenomenal. For a recent AI project I decided to apply Parent&amp;rsquo;s &lt;em&gt;goal&lt;/em&gt; of &amp;ldquo;no raw loops&amp;rdquo;, I was blown away by the transformation&amp;hellip; err std::transformation this had on my code. In this post I indented to demonstrate several complex code blocks, or overly specific code blocks what were replaced by some STL magic. Alexander Stepanov says, &amp;ldquo;&lt;a href=&#34;http://www.youtube.com/watch?v=COuHLky7E2Q&#34;&gt;&amp;hellip;code is a liability.&lt;/a&gt;&amp;rdquo; The more code a program has the more likely it contains bugs. The fewer lines of code, the lesser the opportunity for a bug. I haven&amp;rsquo;t quiet decided if I agree with this point, but it does induce thought either way. Sean Parent&amp;rsquo;s methodology seems to agree, for the purposes of this post we&amp;rsquo;ll agree as well.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;So the assignment statement:&lt;/p&gt;

&lt;blockquote&gt;Suppose that you have purchased a bag of candy which has two flavor: cherry (c) and lime (l). We do not know exactly what kind of bag we bought, but we know that it is one of the following types:

&gt; 
&gt; 
    
&gt;   1. 100% cherry (10% likely)
&gt; 
    
&gt;   2. 75% cherry (20% likely)
&gt; 
    
&gt;   3. 50% cherry (40% likely)
&gt; 
    
&gt;   4. 25% cherry (20% likely)
&gt; 
    
&gt;   5. 0% cherry (10% likely)
&gt; 

You take 11 pieces of candy, all happen to be lime. What bag do you most likely have, and what is the probability the next candy will be a lime?&lt;/blockquote&gt;

&lt;p&gt;So lets start with encoding our data.  First we have 2 types of candy: cherry and lime.  Lets represent that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class lime_type{};
class cherry_type{};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We might expand this later, but for now we just need a way to overload functions on lime candies or cherry candies. This will work just fine.&lt;/p&gt;

&lt;p&gt;Next we have some bags, and associated probabilities&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum Bag {
Bag1 =1,
Bag2,
Bag3,
Bag4,
Bag5};

std::vector&amp;lt;Bag&amp;gt; const bags{Bag1, Bag2, Bag3, Bag4, Bag5};

map&amp;lt;Bag, double&amp;gt; apriori{
{Bag1, 0.1},
{Bag2, 0.2},
{Bag3, 0.4},
{Bag4, 0.2},
{Bag5, 0.1}
};

map&amp;lt;Bag, std::pair&amp;lt;double, double&amp;gt;&amp;gt; candy_dist{
{Bag1, {1.00, 0.00}},
{Bag2, {0.75, 0.25}},
{Bag3, {0.50, 0.50}},
{Bag4, {0.25, 0.75}},
{Bag5, {0.00, 1.00}}
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, pretty straight forward, but the magic is about to happen&amp;hellip;&lt;/p&gt;

&lt;p&gt;Next we have to consume data from a file. Each data set is represented by a series of l or c on a single line. We need to print a graph for each line.  Our example data file looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jwright@jwright-LinuxAwesome:~/workspaces/school/cse471/hw15$ cat data1.txt
l l
l l l l l l l l l l l l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So for our first STL use case. (Actually Boost here, since gcc 4.7.1 doesn&amp;rsquo;t support regex yet, but this functionality will work in gcc 4.9.1).&lt;/p&gt;

&lt;p&gt;The before:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;std::ifstream fin(filename);
    string line;
    while(fin &amp;gt;&amp;gt; line)
    {
        if(line == &amp;quot;l&amp;quot;)
            cout &amp;lt;&amp;lt; &amp;quot;Lime&amp;quot; &amp;lt;&amp;lt; endl;
        if(line == &amp;quot;c&amp;quot;)
            cout &amp;lt;&amp;lt; &amp;quot;cherry&amp;quot; &amp;lt;&amp;lt; endl;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What&amp;rsquo;s wrong with this code block? Consider if our ls and cs aren&amp;rsquo;t white space delimited. Sensor data is noisy/messy all the time. It would be prudent to deal with this case. This code doesn&amp;rsquo;t block on newlines, and streams all the newlines together. We could wrap this code block with a std::getline() loop, but that&amp;rsquo;s going the wrong direction. No raw loops&amp;hellip; What does the STL provide to deal with this? Essentially we want to tokenize each line with _c_s or _l_s as tokens.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;boost::regex reg(&amp;quot;c|l&amp;quot;); //Construct the regular expression here, since it&#39;s expensive
while(std::getline(fin,line))
{ 
    boost::sregex_token_iterator pos(begin(line), end(line), reg);
    boost::sregex_token_iterator end;
    std::for_each(pos, end, [](boost::sregex_token_iterator tok)
    {
        process(tok-&amp;gt;str());
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code isn&amp;rsquo;t directly shorter, but it is certainly more robust. We can deal with extra noise in our data file, and the regex will skip over it gracefully calling our process function once for each l and c it finds on each line.&lt;/p&gt;

&lt;p&gt;Now that we&amp;rsquo;re warmed up, lets check out some better examples. Conditional probabilities have lots of summations, and product chains in them. My initial hack unrolled all these summations. This is both verbose, which can hide errors, but if we can reduce the number of lines we will increase our reliability. First up.&lt;/p&gt;

&lt;p&gt;$$ P( Candy = Lime | Data) = \Sigma_{Bags}(P(lime, Bag_i | Data) $$&lt;/p&gt;

&lt;p&gt;My first hack, looks like something that congealed in a gutter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;double p(cherry_type, data_type)
{
//
// \sigma_bags(p(lime, Bag_i | data))
//
double a =
p(lime_type(), Bag1)*p(Bag1, data_type()) +
p(lime_type(), Bag2)*p(Bag2, data_type()) +
p(lime_type(), Bag3)*p(Bag3, data_type()) +
p(lime_type(), Bag3)*p(Bag4, data_type()) +
p(lime_type(), Bag5)*p(Bag5, data_type());

return a;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This version is has the sad property that a C programmer might say, &amp;ldquo;Awesome, he unrolled the loops. That code will be fast.&amp;rdquo; Stephan T. Lavavej says , &amp;ldquo;&lt;a href=&#34;http://channel9.msdn.com/Events/GoingNative/2013/Don-t-Help-the-Compiler&#34;&gt;Don&amp;rsquo;t help the compiler&lt;/a&gt;&amp;rdquo;. I agree. -funroll-loops will unroll the loops much better than I can.In fact this code as a bug in it. See it?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;double p(cherry_type, data_type)
{
//
// \sigma_bags(p(lime, Bag_i | data))
//
double a =
p(lime_type(), Bag1)*p(Bag1, data_type()) +
p(lime_type(), Bag2)*p(Bag2, data_type()) +
p(lime_type(), Bag3)*p(Bag3, data_type()) +
p(lime_type(), Bag3)*p(Bag4, data_type()) + //Boom, check out that hot copy-paste error.
p(lime_type(), Bag5)*p(Bag5, data_type());

return a;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Corrected, but still not &amp;ldquo;correct&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;double p(lime_type, data_type)
{
//
// \sigma_bags(p(lime, Bag_i | data))
//
double a =
p(lime_type(), Bag1)*p(Bag1, data_type()) +
p(lime_type(), Bag2)*p(Bag2, data_type()) +
p(lime_type(), Bag3)*p(Bag3, data_type()) +
p(lime_type(), Bag4)*p(Bag4, data_type()) + //Boom, check out that hot copy-paste error.
p(lime_type(), Bag5)*p(Bag5, data_type());

return a;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Beside being verbose, and prone to error. It isn&amp;rsquo;t generate. If we grow our dataset, the loop is not wrong. Can we be sure that we&amp;rsquo;ll find every unrolled loop, and fix it? We can do better.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;double p(lime_type, data_type)
{
    //
    // \sigma_bags(p(lime, Bag_i | data))
    //   
    std::vector&amp;lt;double&amp;gt; partials(bags.size());
    std::transform(begin(bags), end(bags), begin(partials), [](Bag b){ return p(lime_type(), b)*p(b, data_type()); });
    double a = std::accumulate(begin(partials), end(partials), 0.0 ); //Gotcha 0.0 instead of 0. 0 will cast the result to an int
    return a;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This version is shorter. The compiler is free to optimize the STL algorithms as needed even unrolling the loops if the compiler deems it will improve the code. This code is readable, but futhermore we can explain this code to a mathematician. Stroustroup says, &amp;ldquo;Express abstracts as the expert in the field does.&amp;rdquo; This function does exactly that. The first step is to compute partial products of $$ P( Lime, Bag_i) * P(Bag_i | Data) $$. Then add the products together. We are agnostic to the number of bags.&lt;/p&gt;

&lt;p&gt;Next what about debugging. I&amp;rsquo;m searching for a bug, and sometimes print statements are the best way to work it out. Lets print out a vector.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vector prob;
//...
cout &amp;lt;&amp;lt; &amp;quot;{&amp;quot;;
for(auto&amp;amp; p : prob)
    cout &amp;lt;&amp;lt; p &amp;lt;&amp;lt; &amp;quot;, &amp;quot;;
cout &amp;lt;&amp;lt; &amp;quot;}&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This cannot be bad right? We used the new, shiny range-based for. What can one complain about.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vector prob;
//...
cout &amp;lt;&amp;lt; &amp;quot;{&amp;quot;;
std::copy(std::begin(prob), std::end(prob), std::ostream_iterator&amp;lt;double&amp;gt;(cout, &amp;quot;, &amp;quot;));
cout &amp;lt;&amp;lt; &amp;quot;}&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However we can do &lt;a href=&#34;https://github.com/louisdx/cxx-prettyprint&#34;&gt;even better&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include 
cout &amp;lt;&amp;lt; prob;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even though this program was small, the opportunity to improve quality, and robustness, is ever present. C++ is a growing language, and it&amp;rsquo;s new capabilities are really improving the corner cases in software. One key tool in doing so is learning the STL.  I encourage you to study the STL.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Text Processing for Programmers</title>
      <link>http://codestrokes.com/2013/02/text-processing-for-programmers/</link>
      <pubDate>Sun, 17 Feb 2013 19:53:11 +0000</pubDate>
      
      <guid>http://codestrokes.com/2013/02/text-processing-for-programmers/</guid>
      <description>&lt;p&gt;I was reading a &lt;a href=&#34;https://sites.google.com/site/steveyegge2/five-essential-phone-screen-questions&#34;&gt;blog &lt;/a&gt;about coding interviews, and one comment made near the bottom struck me, &amp;ldquo;&amp;hellip;&amp;ldquo;Um&amp;hellip; grep?&amp;rdquo; then they&amp;rsquo;re probably OK&amp;hellip;&amp;rdquo;  As I read that comment, I realized I&amp;rsquo;d never answer that way, and I agreed with the author that was a problem. That began my dabble in grep, awk and sed, and these tools will change your workflow and even how you think about profiling code.  Grep has even become a verb in my daily life, &amp;ldquo;Is this &lt;em&gt;greppable?&lt;/em&gt;&amp;rdquo; is my mantra.  Flash forward a few months and once again I had a task for these powerful text processing tools, convert a mysql database to sqlite. Sounds easy, but with file sizes of &amp;gt;700MB, you have to be efficient.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;As part of a machine learning project for a graduate class I&amp;rsquo;m using the enron email &lt;a href=&#34;http://aws.amazon.com/publicdatasets/&#34;&gt;public dataset&lt;/a&gt;. This dataset has been further processed and cleaned at &lt;a href=&#34;http://www.cs.cmu.edu/~enron/&#34;&gt;Carnagie Mellon&lt;/a&gt;. This dataset is so valuable because it is real world email from a functioning orginazation. This dataset is used in human factors research, machine learning, and as in my usecase, data security. I downloaded the mysql version and since I intended to use Python to do my processing I wanted to convert it to sqlite.
[suffusion-adsense client=&amp;lsquo;ca-pub-6284398857369558&amp;rsquo; slot=&amp;lsquo;8519108503&amp;rsquo; width=&amp;lsquo;300&amp;rsquo; height=&amp;lsquo;250&amp;rsquo;]&lt;/p&gt;

&lt;p&gt;My basic process is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Import the dataset into a mysql database&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use this &lt;a href=&#34;https://gist.github.com/esperlu/943776&#34;&gt;gist&lt;/a&gt; to dump the database into sqlite.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Cool. So Step 1.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jwright@ubuntu:~$ mysql -u root -p -h localhost enron &amp;lt; enron-mysqldump.sql 
Enter password: 
ERROR 1064 (42000) at line 10: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;TYPE=MyISAM&#39; at line 8
jwright@ubuntu:~$ grep enron-mysqldump.sql &#39;TYPE-MyISAM&#39;
grep: TYPE-MyISAM: No such file or directory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Damn. Well, lets see what the problem is&amp;hellip; Remember this file is &amp;gt;700 MB so I don&amp;rsquo;t want to just open it in notepad.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jwright@ubuntu:~$ grep &#39;TYPE=MyISAM&#39; enron-mysqldump.sql
 ) TYPE=MyISAM;
 ) TYPE=MyISAM;
 ) TYPE=MyISAM;
 ) TYPE=MyISAM;
 jwright@ubuntu:~$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oh. That&amp;rsquo;s &lt;em&gt;greppable&lt;/em&gt;, awesome.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed &#39;s/TYPE=MyISAM/engine=myisam/g&#39; enron-mysqldump.sql &amp;gt; enron-mysqldump_filtered.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have a clean file for import.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql -u root -p -h localhost enron &amp;lt; enron-mysqldump_filtered.sql
./mysql2sqlite.sh -u root -p enron | sqlite3 enron.db
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;732MB database converted in just a few minutes. Mostly just I/O time. I believe all good programmers show know these tools. I know personally, when I have to export data for profiling or metrics, I do it in a way that I can easily filter with awk, or sed to a format octave can process. Automating measurements will dreastically decrease your cycle time and reduce mistakes.&lt;/p&gt;

&lt;p&gt;So &amp;ldquo;Um&amp;hellip; grep?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Hell yes grep!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Turbulent History of Managed Code</title>
      <link>http://codestrokes.com/2012/08/the-turbulent-history-of-managed-code/</link>
      <pubDate>Tue, 28 Aug 2012 05:31:04 +0000</pubDate>
      
      <guid>http://codestrokes.com/2012/08/the-turbulent-history-of-managed-code/</guid>
      <description>

&lt;p&gt;Managed Code is a fascinating technology; Just-In-Time compilation provides advanced run-time optimization and strong type safety can &lt;a href=&#34;http://channel9.msdn.com/Shows/Going+Deep/Singularity-III-Revenge-of-the-SIP&#34;&gt;render the hardware MMU obsolete&lt;/a&gt;. However the managed code renaissance is again in decline, and interestingly more than technology, business is changing the managed/native landscape. More than any other other metric, managed code is about maximizing programmer productivity.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;In 1977, Infocom released Zork. Zork was an innovative game. Its &lt;a href=&#34;http://www.inform-fiction.org/manual/html/s34.html&#34;&gt;sophisticated&lt;/a&gt; linguistics made for an immersive experience for its adventurers.  Language wasn&amp;rsquo;t the only innovation made by Infocom. Infocom released Zork on a custom virtual machine called the Z-Machine. Z-Machine functioned as an abstraction layer to the hardware, allowing one code base to run on multiple separate architectures. The Z-Machine was a major technical advancement, but more than that it allowed programmers to work on a single code base rather than writing duplicate code for differing architectures.&lt;/p&gt;

&lt;p&gt;The Z-Machine afforded enormous financial benefit by allowing simultaneous release to multiple architectures. However, as Infocom discovered during the development of Cornerstone, Z-Machine did have an enormous performance overhead. Cornerstone was a business database application. Infocom decided early in development that the flexibility Z-Machine afforded Zork, would benefit Cornerstone. Cornerstone however, was not the slow paced text adventure game of Zork. Cornerstone was a serious business class application designed to compete with dBase and FoxPro. Z-Machine permitted more productive programmers but at the cost of performance. Performance Cornerstone direly required.&lt;/p&gt;

&lt;p&gt;The Java programming language, arguably the most popular language in the world, was &lt;a href=&#34;http://en.wikipedia.org/wiki/Write_once,_run_anywhere&#34;&gt;solely designed&lt;/a&gt; to optimize programmer&amp;rsquo;s productivity. Sun first touted this noble goal with the statement, &amp;ldquo;Write once, run anywhere&amp;rdquo;. Java makes many compromises in the name of &lt;em&gt;safety from the programmer&lt;/em&gt;. The managed coder is prevented from low level access to hardware in the name of safety. If the coder cannot segfault, program will be more stable. Java automatically range checks all arrays, and provides a periodic garbage collector, all in the name of stability, security and productivity. Performance is not a metric for this target.&lt;/p&gt;

&lt;p&gt;When Java was release, the hardware at the time was advancing rapidly. Clockspeeds were accelerating at an alarming rate. Hardware engineer&amp;rsquo;s enormous effort allowed software engineers to trade performance. Simultaneously, business applications were growing ever larger. Larger applications meant larger teams. These large teams leveraged Java to help manage some of the preceived ___ problems_ with native code. Simultaneously, this trade of performance afforded the businesses to target multiple architectures from a single code base. Managed code was making a huge surge.&lt;/p&gt;

&lt;p&gt;In 2002, Microsoft was working on Longhorn, and Microsoft started down the same perilous road as Infocom. Jim Allchin released an edict stating that all OS interfaces shall be M&lt;em&gt;anaged Interfaced&lt;/em&gt;._ _The question of the time was, &amp;ldquo;Can Managed Code solve all important problems?&amp;rdquo;, leaving native code only to device drivers. Those who touch the metal.  Native interfaces were permitted, but never in place of managed ones. Microsoft saw the productivity managed interfaces afforded programmers. This meant a healthier bottom line. Microsoft attempted to leverage this harder than anyone had before.  Infocom build a database on managed technologies. Microsoft wanted to build an operating system! Longhorn had an ambitious list of features and managed code was at the center of it all. Eventually, Microsoft forwent managed code and quickly released Vista. Microsoft discovered what Infocom discovered years prior, there are certain limits to managed code&amp;rsquo;s capabilities.&lt;/p&gt;

&lt;p&gt;Fast forward to the era of cloud computing, which is simply a re-branding of yesteryear&amp;rsquo;s time-share systems. Processing time is once again premium to programmer&amp;rsquo;s time. On the hardware side, we&amp;rsquo;ve hit a limit with clock speeds. Increasing the performance of our software applications is no longer up to the hardware engineers, its now our responsibility. We no longer have the luxury of managed code.  Our responsibility is to compute some result and release the systems&amp;rsquo; resources, or for battery powered devices return to low power mode. Native code is the only tool we currently have to leverage the hardware and meet our performance goals.&lt;/p&gt;

&lt;p&gt;Embedded systems are now ubiquitous, where the name of the game is battery life, and immersive apps. Nothing permits us to leverage the advanced features of these embedded processors like native code does. Managed code is faster now too, and will always have a place in application development. However when there is a linear relationship between cost and runtime, Native code is king.&lt;/p&gt;

&lt;h4 id=&#34;references:5d862b683b62e00a04451b62b40cdb50&#34;&gt;References&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ms993883.aspx&#34;&gt;http://msdn.microsoft.com/en-us/library/ms993883.aspx&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.theinquirer.net/inquirer/news/1004218/longhorn-to-have-managed-interfaces&#34;&gt;http://www.theinquirer.net/inquirer/news/1004218/longhorn-to-have-managed-interfaces&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Z-machine&#34;&gt;http://en.wikipedia.org/wiki/Z-machine&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Zork&#34;&gt;http://en.wikipedia.org/wiki/Zork&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.inform-fiction.org/zmachine/standards/index.html&#34;&gt;http://www.inform-fiction.org/zmachine/standards/index.html&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Java_performance&#34;&gt;http://en.wikipedia.org/wiki/Java_performance&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Jim_Allchin&#34;&gt;http://en.wikipedia.org/wiki/Jim_Allchin&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2012/-Not-Your-Father-s-C-?format=html5&#34;&gt;http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2012/-Not-Your-Father-s-C-?format=html5&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://herbsutter.com/2012/04/02/reader-qa-when-will-better-jits-save-managed-code/&#34;&gt;http://herbsutter.com/2012/04/02/reader-qa-when-will-better-jits-save-managed-code/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.gotw.ca/publications/concurrency-ddj.htm&#34;&gt;http://www.gotw.ca/publications/concurrency-ddj.htm&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://herbsutter.com/welcome-to-the-jungle/&#34;&gt;http://herbsutter.com/welcome-to-the-jungle/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>The Importance of System Design</title>
      <link>http://codestrokes.com/2012/07/the-importance-of-system-design/</link>
      <pubDate>Sun, 15 Jul 2012 17:00:44 +0000</pubDate>
      
      <guid>http://codestrokes.com/2012/07/the-importance-of-system-design/</guid>
      <description>&lt;p&gt;For the small programs we tend to implement as part of a semester project, or the simple &amp;ldquo;one-off/get-it-done&amp;rdquo; programs at work, system design rarely plays a part. However, even in the smallest problems a top-level system design is critical for consistency and ease of use. Class components, regardless of how precise and accurate they are in their own internal design, if they aren&amp;rsquo;t externally consistent with other objects, the system will be brittle, and difficult to use.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;In a recent project, I used a bottom-up approach. I designed each class in isolation. I was very diligent to define the ownership semantics, and use each smart pointer and r-value reference type correctly. Despite all the time spent on the details of each object, when I tried to use the objects together, their interfaces were so inconsistent the individual objects were unusable. Case in point:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(auto playersHand : player)
{
    if(playersHand-&amp;gt;Value() &amp;gt; dealersHand-&amp;gt;Value())
    {
        player.Win(*playersHand-&amp;gt;GetBet().get()); //&amp;lt;-- This is a red-flag
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you have to retrieve the raw pointer from the smart_pointer container, you are doing something wrong.&lt;/p&gt;

&lt;p&gt;Here the Player wants a reference to the winning Bet. The player doesn&amp;rsquo;t own the bet, nor does it modify it, it just wants a reference, so I used the &lt;em&gt;passing by const-to-reference&lt;/em&gt; idiom. The Hand however shares a reference between the Table, and the Player. So I used a shared_ptr&lt;Bet&gt;.  shared_ptr implies that it owns and entirely manages the underlying pointer. Smart pointers can reduce or eliminate raw pointers in your system, making it safer. Fetching the raw pointer from such a container invites even bigger problems than managing the raw pointer yourself. Now you have two entities claiming ownership of a raw pointer. This is a fast way to a double-delete problem or more likely a memory leak.&lt;/p&gt;

&lt;p&gt;C++11 contains a powerful number of tools to allow more general components in our designs. This is however, a two-edge sword. Generic components are great. They enable tested code to be reused across multiple projects. This alone improve quality, and reduces time-to-market. Derisking our projects is a very positive thing, and we should continue doing so.&lt;/p&gt;

&lt;blockquote&gt;Time-to-market is an important metric for academic projects as well. Reducing time-to-market, derisks your ability to complete the project before the due date. This allows you to tackle a more ambitious solution...&lt;/blockquote&gt;

&lt;p&gt;C++11&amp;rsquo;s generalization tools also allow code to be more easily refactored. Take for instance the following C++98 code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; for(vector&amp;lt;shared_ptr &amp;gt;::iterator player = players_.begin(); 
    player != players_.end();
    ++player)
{
    for(vector&amp;lt;shared_ptr &amp;gt;::iterator playersHand = player.begin();
            playersHand != player.end();
            ++playersHand)
    {
        /** ... Other Code Here ... */
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compared to the equivalent C++11 code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(auto player : players_)
{
    for(auto playersHand : player)
    {
        /** ... Other Code Here ... */
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, typedefs can help here, but the C++11 version is still far more general. There are no types explicitly called out in the for loops. This is immensely powerful. It allows one to change the underlying container in each type, and the for loop simply iterates over the new type. This makes refactoring easier, but making the code more general also makes a system design more important than ever. As our code becomes more general its more important that types behave consistantly. For example, look at the C++98 version above. By looking at the iterator declaration, we know that we&amp;rsquo;re iterating over a shared pointer, ergo we&amp;rsquo;ll use the -&amp;gt; operator. However in the C++11 version we have no idea what type player is. Its declared with auto, and fed by our user defined type. Where C++98 used declarations to state the interface, C++11 requires consistency.&lt;/p&gt;

&lt;p&gt;Within a program, the designer must make broad statements over the objects&amp;rsquo; behavior. If all objects within a system behave the same, then the users of those components can expect a certain level consistency. It becomes clear which use cases of an object are correct and which are not. This follows from Joel Spolsky&amp;rsquo;s idiom &lt;a href=&#34;http://www.joelonsoftware.com/articles/Wrong.html&#34;&gt;Make Wrong Code Look Wrong&lt;/a&gt;.  The compiler can tell us we are using the wrong operator, but this is a sign that we&amp;rsquo;re lacking a consistent interface with our objects. Notice however that the compiler cannot tell us if we are using the object in a semantically incorrect way. Just because it compiles, doesn&amp;rsquo;t mean its right. Scott Meyers puts this as: &amp;ldquo;Make interfaces easy to use correctly and hard to use incorrectly.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Use the new generalization tools in C++11. It will make your code better. Our programs have always needed a system-design; it&amp;rsquo;s simply more apparent now. C++11 enables you to make better quality systems by forcing consistency across your objects and simultaneously making your code more general &lt;a href=&#34;http://tirania.org/blog/archive/2012/Apr-04.html&#34;&gt;without sacrificing performance&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Copyright - The Anti-Innovator</title>
      <link>http://codestrokes.com/2012/04/copyright-the-anti-innovator/</link>
      <pubDate>Sat, 14 Apr 2012 17:53:21 +0000</pubDate>
      
      <guid>http://codestrokes.com/2012/04/copyright-the-anti-innovator/</guid>
      <description>&lt;p&gt;The French government dismantled and destroyed the &lt;em&gt;Mona Lisa&lt;/em&gt;, along with a number of other masterpiece paintings today after courts decided that paintbrushes are copyrighted. Furthermore their derivative works, i.e. items creating using paintbrushes, are subject to copyright infringement. This of course is a fabrication, but this is exactly the point Oracle is trying to make when trying to &lt;a href=&#34;http://www.wired.com/wiredenterprise/2012/04/google-oracle/&#34;&gt;copyright programming languages&lt;/a&gt;. Programming languages are tools for programmers to create the world we live in. Everything we do in modern society is influenced by software. Software&amp;rsquo;s ubiquity is directly correlated to the continued innovation in compilers, and software technology. If we allow the tools to be copyrighted, we relegate ourselves to a world further fraught with lawyers, licensing and stagnated innovation.&lt;/p&gt;

&lt;p&gt;&amp;lt;!&amp;ndash; more &amp;ndash;&amp;gt;In an &lt;a href=&#34;http://channel9.msdn.com/Shows/Going+Deep/Expert-to-Expert-Rich-Hickey-and-Brian-Beckman-Inside-Clojure&#34;&gt;interview with Channel 9&lt;/a&gt;, Rich Hickey was commenting on why he chose Lisp as the basis for his fantastic Clojure Project.  Imagine for a moment that Lisp was copyrighted. Rich Hickey would be held up in courts defending his language, rather than offering a new and fresh tool to modern programmers.&lt;/p&gt;

&lt;p&gt;[suffusion-adsense client=&amp;lsquo;ca-pub-6284398857369558&amp;rsquo; slot=&amp;lsquo;2539579908&amp;rsquo; width=&amp;lsquo;728&amp;rsquo; height=&amp;lsquo;90&amp;rsquo;]&lt;/p&gt;

&lt;p&gt;One of the beautiful things I love about programming is that the skills in one language are transferable to other languages. Great programmers find interesting way to use existing idioms, in new languages. This results in powerful and useful patterns, from which the entire industry benefits.  Its easy to see that &lt;a href=&#34;http://www.levenez.com/lang/&#34;&gt;programming languages are all connected&lt;/a&gt;. D is slated to be a &amp;ldquo;&lt;a href=&#34;http://www.drdobbs.com/parallel/217801225&#34;&gt;better C++&lt;/a&gt;&amp;rdquo;, and in many ways it is. C++ was intended to be a better C, all of the low level access, extreme performance, but with additional modeling power. C came from BCPL. If BCPL was copyrighted, there wouldn&amp;rsquo;t be a C, or C++. Richard Stallman wouldn&amp;rsquo;t have been able to start gcc. Without gcc, &lt;a href=&#34;https://www.linux.com/news/featured-blogs/196-zonker/556977-the-compiler-that-changed-the-world-turns-25&#34;&gt;we wouldn&amp;rsquo;t have Linux&lt;/a&gt;.  On the bright side we wouldn&amp;rsquo;t have Java either, but I digress.&lt;/p&gt;

&lt;p&gt;I believe, Linux is one of the most innovative kernels on the planet. It is a powerful tool used as the basis for businesses around the world. Without the free (free as in speech) transfer of these ideas software would be left to those who could afford the formal training and licensing fees. Take FPGAs for example. The &lt;a href=&#34;http://model.com/content/modelsim-pe-student-edition-hdl-simulation&#34;&gt;simulators&lt;/a&gt; and &lt;a href=&#34;http://www.altera.com/download/licensing/lic-index.html&#34;&gt;compilers&lt;/a&gt; for FPGA technology are proprietary, and expensive. How many open-source FPGA projects are there? Few. The barrier for entry is just too great. A motivated student isn&amp;rsquo;t going to learn FPGAs. As such there are few engineers who have this increasingly valuable skill. Furthermore, there aren&amp;rsquo;t new and interesting testing components in the field. The technology moves only as fast as vendors choose it to. When one limits access to tools, they impend the entire industry. Limiting an industry, yes but stagnation affects the society as a whole as well.&lt;/p&gt;

&lt;p&gt;The automotive industry is starting to have this problem. When I was a kid, I would change the oil on my grandparents cars for side money. That can&amp;rsquo;t happen now. The automtive industry has increasingly made the tools for working on cars proprietary. Only dealers have access to some tools critical for basic maintenance of a vehicle. The result? People cannot even change a tire today. Limiting access has decreased the overall capability of our society.&lt;/p&gt;

&lt;p&gt;Copyright law has gotten out of hand, and if it continues in this manner, innovation in areas of technology will come to a screetching halt.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Branching with Mercurial</title>
      <link>http://codestrokes.com/2012/02/branching-with-mercurial/</link>
      <pubDate>Mon, 20 Feb 2012 02:18:15 +0000</pubDate>
      
      <guid>http://codestrokes.com/2012/02/branching-with-mercurial/</guid>
      <description>&lt;p&gt;Mercurial supports two separate methods for branching. The first is built into how distributed version control functions, in that every clone is a branch itself. This is the branching method Joel Sposky recommends on hginit.com. The second method is called &lt;em&gt;&lt;a href=&#34;http://mercurial.selenic.com/wiki/Branch&#34;&gt;local branches&lt;/a&gt;&lt;/em&gt;. Initially I liked the local branch method; I liked it for the fact that I felt smart for using it. It did not improve productivity. There is a simple reason for this, with local branches it is difficult to diff the branch to the main branch of development e.g. the trunk. This post will walk through local branches, how I used then, and finally, how I quit local branches in favor of a cloning approach.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;I use version control because I like to experiment when I code. I frequently approach a class design as: What if &lt;em&gt;this&lt;/em&gt; happened? Frequently, people comment, &amp;ldquo;I don&amp;rsquo;t need version control; I&amp;rsquo;m just one person.&amp;rdquo; This is a rather naive perspective on version control. Yes, version control can be used to collaborate work between different people or different teams. In fact, originally, this was it&amp;rsquo;s primary use case, however version control is so much more.&lt;/p&gt;

&lt;p&gt;Personally, I feel very unsafe when working without version control, its coding without a safety net. Once you get something working, you don&amp;rsquo;t want to touch it because you might never be able to get it back to this working state again. Version control fixes this behavior. When you get a semi-working version of something &lt;strong&gt;tag it&lt;/strong&gt; then keep working; if you get something better, tag again. If you break it completely, revert back to the previous tag.  Its a great tool. Branches are that idea on steroids. I use branches extensively, at work I tag of ever issue number, for school/home I tag on each capricious thought. One project I implemented the &lt;a href=&#34;http://www.codestrokes.com/2011/10/parallel-game-of-life/&#34;&gt;Game of Life&lt;/a&gt;, as a conduit to experiment with OpenMP. At one time I had 6 parallel branches each with a different experiment or idea:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Parallel Game of Life&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;data_dependency_tests&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;octave_experiments&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;pthread_vs_openmp&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;graphical_debugger&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;parallel-game-of-life&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SDL_ext_experiments&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Originally, I tried using local-branches. This is the &lt;em&gt;hg branch&lt;/em&gt; command. Just type hg branch, and a branch name, then keep working. To switch between branches use hg update -c &lt;branch_name&gt;. This is the problem. Its hard to work on multiple branches at that same time. I was constantly switching between branches, and that wasn&amp;rsquo;t very productive.&lt;/p&gt;

&lt;p&gt;The one upside to local branches is that all the branches are carried with the repository, so you can work on multiple branches on different computers just by cloning one repository. However the loss of productivity by constantly switching between different branches was too much. I now do something different. I clone for a branch. When I check out a new project, I create a directory first, then clone my remote-repository into that folder with the name _top _i.e. top-level. Then I hg clone any branches I want and start working. This makes it very easy to merge, between working copies, and diff changes. Then If I don&amp;rsquo;t like an idea I can throw it away completely, and it doesn&amp;rsquo;t dirty my changeset history!&lt;/p&gt;

&lt;p&gt;Here is a snapshot of a project with all branches:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.codestrokes.com/wp-content/uploads/2012/02/Screenshot-GOF.png&#34;&gt;&lt;img src=&#34;http://www.codestrokes.com/wp-content/uploads/2012/02/Screenshot-GOF-300x272.png&#34; alt=&#34;&#34; /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now I can create a tab in vim, and open each branch into a separate tab. Awesome!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Making C&#43;&#43; like Python: The Anderson Smart Pointer Pattern</title>
      <link>http://codestrokes.com/2011/10/making-c-like-python-the-anderson-smart-pointer-pattern/</link>
      <pubDate>Sun, 23 Oct 2011 19:00:21 +0000</pubDate>
      
      <guid>http://codestrokes.com/2011/10/making-c-like-python-the-anderson-smart-pointer-pattern/</guid>
      <description>&lt;p&gt;Choosing to use C++ brings the additional complexity of memory management.  Dennis Ritchie once stated: The C Programming Language — A language which combines the flexibility of assembly language with the power of assembly language. C++ inherits much of that _flexibility, _however, this &lt;a href=&#34;http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey&#34;&gt;incidental complexity&lt;/a&gt;, can be relegated to a single class, leaving you with the high-level elegance of Python. RAII help with this additional complexity, however without a pattern for guidance implementing RAII consistently can be difficult, defeating the safety it provides.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;Resource Acquisition Is Initialization (&lt;a href=&#34;http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&#34;&gt;RAII&lt;/a&gt;) is a powerful tool for managing resources.  RAII &lt;a href=&#34;http://www.research.att.com/~bs/bs_faq2.html#finally&#34;&gt;justifies&lt;/a&gt; the apparent missing finally clause. Stroustrup claims that with proper RAII,  &lt;a href=&#34;http://www.research.att.com/~bs/bs_faq2.html#finally&#34;&gt;finally&lt;/a&gt; is not required. D also &lt;a href=&#34;http://www.d-programming-language.org/exception-safe.html&#34;&gt;implements&lt;/a&gt; RAII with scope operators. Ok, so RAII is powerful, but what is it?&lt;/p&gt;

&lt;p&gt;In C++, destructors are the only entity guaranteed to execute after an exception.  So resources which need to be automatically reclaimed need  to acquire at initialization, and release at destruction.  Such resources must be declared on the stack, to permit this idiom.&lt;/p&gt;

&lt;p&gt;Writing exception-safe code, e.g. managing resources throughout exceptions is difficult, and while RAII makes it easier, managing RAII correctly is difficult without a pattern. A colleague of mine, &lt;a href=&#34;http://www.chrisanderman.com/&#34;&gt;Anderson&lt;/a&gt;, developed a fantastic pattern/&lt;a href=&#34;http://erdani.com/publications/cuj-2005-12.pdf&#34;&gt;policy&lt;/a&gt; using smart pointers which makes RAII automatic.&lt;/p&gt;

&lt;p&gt;Two patterns compose the Anderson Smart Pointer Pattern: Factory Constructor, and PIMPL.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifdef _WIN
#include &amp;lt;memory&amp;gt;
#else
#include &amp;lt;tr1/memory&amp;gt;
#endif

class Name
{
public:
#ifdef _WIN
    typedef std::shared_ptr Ptr; //This uses the class as a namespace.
    typedef std::weak_ptr WeakPtr;
#else
    typedef std::tr1::shared_ptr Ptr;
    typedef std::tr1::weak_ptr WeakPtr;
#endif
    static name::Ptr construct(); //Factory Constructor
    virtual ~name();
private:
    Name(); //Notice the constructor is private
    name::WeakPtr self; //self (from python), replaces this
};

Name::Ptr Name::construct()
{
    Name::Ptr c(new Name());
    //Self completes the PIMPL idiom,
    //thereby hiding all behavior behind a safe, reference counted wall
    c-&amp;gt;self = c;
    return c;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This pattern is used as an RAII &lt;a href=&#34;http://erdani.com/publications/cuj-2005-12.pdf&#34;&gt;policy&lt;/a&gt;. Using the pattern liberally can eliminate new and delete from your program, and you will not leak memory. Even with multiple exceptions, you&amp;rsquo;re &lt;a href=&#34;https://bitbucket.org/jwright/cse310-red-black-tree/overview&#34;&gt;program will not leak&lt;/a&gt;.  Creating an instance of an RAII class is easy now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Name::Ptr myInstance = Name::construct();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This Pattern will make one extra virtual call as it performs the reference counting, but the performance hit is typically nominal compared to the safety it provides to the system. The Anderson Smart-Pointer Pattern increases robustness of your programs, but interestingly it also provides a new elegance. Since one is not managing memory, and resources constantly, it makes C++ perform more like a high level language. For example, I implemented a &lt;a href=&#34;https://bitbucket.org/jwright/cse310-red-black-tree/src/d787e75b724a/BaseCode/RedBlackTree.cpp#cl-137&#34;&gt;red black tree&lt;/a&gt; using this pattern.  I didn&amp;rsquo;t need to worry about deleting nodes, just the requirements of my program. With the incidental complexity relegated to a single class, I am left with the elegant, expressiveness of Python, yet retain the raw performance of C++.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hijacking System Programs</title>
      <link>http://codestrokes.com/2011/08/hijacking-system-programs/</link>
      <pubDate>Fri, 12 Aug 2011 06:00:18 +0000</pubDate>
      
      <guid>http://codestrokes.com/2011/08/hijacking-system-programs/</guid>
      <description>&lt;p&gt;Let&amp;rsquo;s say for a moment that you are a graduate student, with shell access to your schools server. The server maintains a number of tools you need for classes, and research.  All is well, except the stock editor on the server is wicked old.  Like an eternity old.  Well that happened to me. I am fully addicted to &lt;a href=&#34;https://bitbucket.org/jwright/vim-configuration&#34;&gt;my custom vim configuration&lt;/a&gt;, but it requires vim7.3.  My school&amp;rsquo;s server only has 7.0.  So, how does one install their own application with root privledges?  You create a private root.&lt;/p&gt;

&lt;p&gt;&amp;lt;!&amp;ndash; more &amp;ndash;&amp;gt;The goal is to install a custom application which either is not available on they system, or the version available is tool old.  Essentially, you just need to install the program to your home folder, and add the new binary to your path.  Here is how I did just that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. Download your program of choice (vim in my case):


-bash-3.2$ wget ftp://ftp.vim.org/pub/vim/unix/vim-7.3.tar.bz2





2. untar the application to build it:


-bash-3.2$ tar -jxf vim-7.3.tar.bz2





3. Make a folder to hold your new custom applications:


-bash-3.2$ mkdir ~/prvt-root





4. Configure the application with a custom prefix: (Notice the backtick.  --prefix requires an absolute directory. The backtick requests the shell to expand your home directory prior to calling configure.)


-bash-3.2$ cd vim73
-bash-3.2$ ./configure --prefix=`~/prvt-root/` --with-features=huge





5. Make and install the app to your Private Root:


-bash-3.2$ make &amp;amp;&amp;amp; make install





6. Modify your path to include your new root:


-bash-3.2$ nano ~/.bash_profile
#Add the following lines to .bash_profile
PATH=~/prvt-root/bin:$PATH #Notice that your bin directory is BEFORE the system&#39;s default. This will allow your bin to be search first!
export PATH





7. Exit and log back in to use your new application!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://www.codestrokes.com/wp-content/uploads/2011/08/CustomVim7.3.png&#34;&gt;&lt;img src=&#34;http://www.codestrokes.com/wp-content/uploads/2011/08/CustomVim7.3.png&#34; alt=&#34;&#34; /&gt;
&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Version Control More Than Collaboration</title>
      <link>http://codestrokes.com/2011/07/version-control-more-than-collaboration/</link>
      <pubDate>Wed, 06 Jul 2011 05:18:48 +0000</pubDate>
      
      <guid>http://codestrokes.com/2011/07/version-control-more-than-collaboration/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve used version control in some form or another since I was a freshman in college, however I&amp;rsquo;m quite the anomaly.  I will use a tool fully knowing that its more than I need, just to learn something new.  Initially, this is how I approached version control. Except for a few unique situations version control of my homework, seemed like more work than it was worth.  I used to think version control was merely a collaboration tool for teams of people.  I couldn&amp;rsquo;t have been more wrong.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;Now I teach a small not-for-credit C++ class at ASU, and one of my students said something interesting:&lt;/p&gt;

&lt;blockquote&gt;I would use version control, but I&#39;m only one person. Why do I need a collaboration tool for just myself?&lt;/blockquote&gt;

&lt;p&gt;I thought it was an excellent perspective, version control is primarily intended as a collaboration tool, simply look at &lt;a href=&#34;https://github.com/&#34;&gt;github&lt;/a&gt;&amp;rsquo;s slogan: _Social Coding.  _Coding for &lt;strong&gt;groups of people&lt;/strong&gt;. Yet, version control is much more than that.  For instance how many times when writing a paper, do you use the Undo? For most non-technical computer users, its probably the only keyboard shortcut they know: Ctrl+Z.  Version control is essentially** infinite undo**. Revert is great.  It frees you from fear of breaking existing code.&lt;/p&gt;

&lt;p&gt;I have a friend, lets call him my &amp;ldquo;lets-get-serious-friend&amp;rdquo;.  Who is great at hacking out piles of code until something works. If you need a quick, solution this friend can nail it.  He&amp;rsquo;ll try several different approaches toward a problem. If that doesn&amp;rsquo;t work he&amp;rsquo;ll comment out the function, with a comment of why it didn&amp;rsquo;t work.&lt;/p&gt;

&lt;p&gt;He&amp;rsquo;s very organized about it, and its a solid approach for him. Yet, after he&amp;rsquo;s finished a solution, he cannot quite remove all the dead code. Writing code is an artistic process and throwing code away, even if it doesn&amp;rsquo;t quite work, is emotional. When the code is particularly clever, it is especially hard to hit the delete key (or rather the dd &amp;ldquo;key&amp;rdquo; :-).  Version control lets you remove all that emotion. You can keep it all, every version.  If in the future you find a use for that clever tidbit, its tucked away safely in your code repository.&lt;/p&gt;

&lt;p&gt;Undo is nice, and being able to keep everything is better, but the nirvana of coding is branching. I came from subversion, so I never really learned to branch. However with my recent &lt;a href=&#34;http://www.codestrokes.com/2011/06/game-framework-for-c-practicum/&#34;&gt;Game Components&lt;/a&gt; project, I&amp;rsquo;ve really been leveraging the hg branch command.  Joel Spolsky says &lt;a href=&#34;http://hginit.com/00.html&#34;&gt;not to use the named branch&lt;/a&gt; feature in Mercurial, however I disagree; and the &lt;a href=&#34;http://blogs.atlassian.com/devtools/2011/06/fisheye-crucible-26-commit-graph.html&#34;&gt;Crucible/Fisheye&lt;/a&gt; team at Atlassian use named branches so its can&amp;rsquo;t be all bad.  Let me give you an example.&lt;/p&gt;

&lt;p&gt;I was hacking on the Models for my Game Components project, I &lt;a href=&#34;https://bitbucket.org/jwright/gamecomponents/changeset/10efe59c3d75&#34;&gt;committed&lt;/a&gt; the code,  but I wasn&amp;rsquo;t really happy with the result. I decided a ModelFactory might be useful in fixing some of the code smell.  The code I had worked, but it was quite fragile, and it required the controller to know too much about the data.  _I think_ a factory will solve the problem, but I&amp;rsquo;m not quite sure.  I could try it out, and if it doesn&amp;rsquo;t work revert, but refactoring in a ModelFactory is a bigger effort than I could support that day. So I branched:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hg branch ModelFactory
hg update -C ModelFactory
hg commit --new-branch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Excellent. Now I have a clean place to play with my idea. If it fails I can just kill the branch, but the really great thing if I get stuck, I can jump back to my main (default) branch and continue working on some other component of my game:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hg update -C default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So branching is a tool to help you deal with writer&amp;rsquo;s block.  In a way, branching is like a little drawer.  When you want to work on that little project, open the drawer and pull out the item.  When you&amp;rsquo;re bored or stuck, but it back in the drawer. Its always there. Its easily accessible, but it doesn&amp;rsquo;t clutter up your workspace.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://bitbucket.org/jwright/gamecomponents/changeset/7f49b0b960c8&#34;&gt;Currently&lt;/a&gt;, I&amp;rsquo;m still not convinced the ModelFactory fixes my issue, so I&amp;rsquo;m working on the level editor now, on the DialogEditorTool branch. School starts in about 1 month so I gotta figure it out by then, but it&amp;rsquo;s there, in a branch, organized, and out of the way.  So version control is more than just a collaboration tool. It helps you permits you to keep your files clean, and free of dead code, while keeping every bit and byte. Version control, help you grow your code without fear of permanently losing some fragile configuration.  Its an process to help you stay organized even if your development plans aren&amp;rsquo;t.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Being Truely Productive</title>
      <link>http://codestrokes.com/2011/06/being-truely-productive/</link>
      <pubDate>Sun, 19 Jun 2011 18:59:47 +0000</pubDate>
      
      <guid>http://codestrokes.com/2011/06/being-truely-productive/</guid>
      <description>&lt;p&gt;Productivity is an elusive mistress.  I approach productivity much like any design problem. I lay out my requirements, and I iterate until I am happy with the outcome. Over the last few years I have spent a lot time laying out my design process.  Along the way I found a number of tools that were helpful.  This is my personal process and while I think it&amp;rsquo;s a great process.  It&amp;rsquo;s important to refactor for yourself. The key to my productivity is consistency. I work well with a defined workflow. Lastly, interruptions are a certainty, so one must find a way to make context switches less disruptive.&lt;/p&gt;

&lt;blockquote&gt;Try to setup natural stopping points in your process. You will be interrupted so make context switches cheap.&lt;/blockquote&gt;

&lt;p&gt;Consistency &lt;em&gt;is&lt;/em&gt; my process, and tools help me deal with strict and dynamic constraints.  I use a number of tools help me be productive, yet consistency is the most powerful function for me.&lt;/p&gt;

&lt;p&gt;&amp;lt;!&amp;ndash; more &amp;ndash;&amp;gt;Firstly, everyone needs a personal database. This is critical. A software engineer&amp;rsquo;s job isn&amp;rsquo;t really about writing code.  Its about organizing information, namely requirements, and teaching them to the computer. One needs a tool that can help organize this data.  I&amp;rsquo;ve used a number of tools, TomBoy is a close second, however I found that &lt;a href=&#34;http://www.amazon.com/gp/product/B0039L2XMA/ref=as_li_ss_tl?ie=UTF8&amp;amp;tag=codestro-20&amp;amp;linkCode=as2&amp;amp;camp=217145&amp;amp;creative=399369&amp;amp;creativeASIN=B0039L2XMA&#34;&gt;OneNote&lt;/a&gt; cannot be beat. Especially, with the new WebApp versions on live.com, I can use &lt;a href=&#34;http://www.amazon.com/gp/product/B0039L2XMA/ref=as_li_ss_tl?ie=UTF8&amp;amp;tag=codestro-20&amp;amp;linkCode=as2&amp;amp;camp=217145&amp;amp;creative=399369&amp;amp;creativeASIN=B0039L2XMA&#34;&gt;OneNote&lt;/a&gt; on any platform, even when I am not home.  &lt;a href=&#34;http://www.amazon.com/gp/product/B0039L2XMA/ref=as_li_ss_tl?ie=UTF8&amp;amp;tag=codestro-20&amp;amp;linkCode=as2&amp;amp;camp=217145&amp;amp;creative=399369&amp;amp;creativeASIN=B0039L2XMA&#34;&gt;OneNote&lt;/a&gt; is a table of contents for my brain.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.codestrokes.com/wp-content/uploads/2011/06/OneNoteOnline.png&#34;&gt;&lt;img src=&#34;http://www.codestrokes.com/wp-content/uploads/2011/06/OneNoteOnline-300x161.png&#34; alt=&#34;Screenshot of OneNote on Live.com&#34; /&gt;
&lt;/a&gt;This brings me to a struggle I had to overcome. When I was in college, I enjoyed hating Microsoft. It was more of a social thing than an actual reason. Later I found that, there is balance, I don&amp;rsquo;t have to be a Microsoft Fan-Boy to use their products. Use what works for you. Just because it isn&amp;rsquo;t FSF, or GNU software doesn&amp;rsquo;t mean its crap.  In fact it may be exactly what you need.&lt;/p&gt;

&lt;blockquote&gt;Don&#39;t undermine your productivity just to make a statement.&lt;/blockquote&gt;

&lt;p&gt;It is crucial that I maintain a homogeneous workflow regardless of my environment: Windows/Linux, Home/School/Office etc.  When choosing tools, I tend to not look for the most powerful, yet instead I search for  the simplest, lowest common denominator.  I use Vim, as an editor, and IDE. The Visual Studio IDE is  fantastic, but can I write Verilog in it? No. Eclipse is nice and  cross-platform, but can I edit .sdc files? No.  Vim is powerful, and  ubiquitous. I can do all of my work, anything I am tasked  with, in Vim. FPGA, C++, Java, C# .NET, PIC C, write a love letter to my  wife (probably most the important task), Vim does it all.   Regardless of the language, platform, or toolchain my editor is consistent. Constantly changing tools, helps you learn, but will not help you be more productive. Regardless of which tools you use, use them consistently.  The only downside I&amp;rsquo;ve found in learning Vim, has been if for some reason I am in any other editor I litter the page with little &lt;em&gt;:w&lt;/em&gt;. Here is my &lt;a href=&#34;https://bitbucket.org/jwright/vim-configuration&#34;&gt;Vim Configuration.&lt;/a&gt; I am working on a dedicated article on my vim configuration. Lookout for it here.&lt;/p&gt;

&lt;p&gt;Save everything.  Tool configurations, one-off scripts, capricious prototypes.  Keep it all.  It&amp;rsquo;s important to realize that everything you create has value, and the value changes over time.  Keep it. I use mercurial.  It seems the DVCS movement is really taking over in cutting edge development companies.  Companies like &lt;a href=&#34;http://blogs.atlassian.com/developer/2011/02/moving_to_mercurial_-_why_we_did_it.html&#34;&gt;Atlassian&lt;/a&gt;. DVCSs such as git, and mercurial do a number of things different that make the process more productive, but the single reason I switched to mercurial from subversion: &lt;strong&gt;Local Commits&lt;/strong&gt;.  I cannot state enough how local commits have made me a better programmer.  Local commits do two things for me. They make context switches (i.e. interruptions) cheap, and local commits let me make more mistakes.&lt;/p&gt;

&lt;p&gt;More mistakes? How does more mistakes make one &lt;em&gt;more productive&lt;/em&gt;.  Simple, I keep a history of all my mistakes so I am not destined to repeat them.  Very often when I am working on a project I want to experiment with some new idiom or pattern.  I use the local commit like a video game save-point.  The commit message is usually something to the effect of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Mercurial Commit:
Probably a bad idea. :-/ Save point for PIMPL experiment.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I freely continue with my idea. If it works out well, then excellent I can always look back and see how I added a given idiom to some existing code. Yet, more typically, my experiment is an utter failure.  I just hg revert, and done. However all is not lost, all that history is saved. I can always look back and see how I applied or rather misapplied my experiment. Reviewing my mistakes helps me to improve. Vim has nearly infinite undo, &lt;a href=&#34;https://groups.google.com/group/vim_announce/browse_thread/thread/66c02efd1523554b?pli=1&#34;&gt;persistent undo&lt;/a&gt;, and &lt;a href=&#34;http://vimdoc.sourceforge.net/htmldoc/undo.html&#34;&gt;branching undo&lt;/a&gt;, all in an effort to provide similar functionality.  This however is not sufficient. Mercurial lets you save your mistakes!&lt;/p&gt;

&lt;blockquote&gt;Saving your mistakes may even be more important than the final solution.&lt;/blockquote&gt;

&lt;p&gt;Prototyping is an important way to gauge investment of your time. Before you start a project work out a bit of a prototype.  Sometimes I get an idea in my head and I just start hacking, usually once I get the idea flushed out I&amp;rsquo;m done.  I just wanted to see, &amp;ldquo;Will that work?&amp;rdquo; Prototyping makes this easy without being too costly, time wise.  I use 3 tools for my prototypes: Python, Octave, and Excel.  Between these three there isn&amp;rsquo;t much one cannot do. Excel is great for just pounding out some number. I frequently use excel to mock out data sets to see where I need to instrument my code to capture some concept.&lt;/p&gt;

&lt;p&gt;Lastly, you need a coding standard.  All the time. When writing personal code, maintainable typically isn&amp;rsquo;t a concern. It&amp;rsquo;s your code, you understand it. It&amp;rsquo;s probably not a long lived project. A coding standard however doesn&amp;rsquo;t slow you down, it makes you more effective.  If you write software consistently, you can lever &lt;a href=&#34;https://bitbucket.org/jwright/vim-configuration/src/1da9bad9fe53/snippets/&#34;&gt;snippet tools&lt;/a&gt;, and code formatting tools to generate boiler plate for you. If you always use the same class layout its easy to go back and find what you need. Yet most important for me, consistency makes &lt;a href=&#34;http://www.joelonsoftware.com/articles/Wrong.html&#34;&gt;wrong code look wrong&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Tools are important. As you can see, I use a number of tools regularly, however the best weapon against time is consistency.  Be consistent in your process, and you will reap rewards.  Please leave your comments. I am curious what tools and processes you, my readers, implement.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>