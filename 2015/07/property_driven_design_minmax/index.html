<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <title>
    Property Driven Design: MinMax // Code Strokes
  </title>

  <link href="http://gmpg.org/xfn/11" rel="profile">
<meta http-equiv="content-type" content="text/html; charset=utf-8">


<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

<meta name="description" content="">
<meta name="keywords" content="">
<meta name="author" content="Jeremy">

  <meta property="og:title" content="Property Driven Design: MinMax" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:locale" content="en_US" />
<meta property="og:url" content="http://codestrokes.com/2015/07/property_driven_design_minmax/" />


  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.5.0/base-min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.5.0/pure-min.css">
  
  
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.5.0/grids-responsive-min.css">
  
  

  <link rel="stylesheet" href="http://codestrokes.com//css/redlounge.css">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
  <link href='//fonts.googleapis.com/css?family=Raleway:400,200,100,700,300,500,600,800' rel='stylesheet' type='text/css'>
  <link href='//fonts.googleapis.com/css?family=Libre+Baskerville:400,700,400italic' rel='stylesheet' type='text/css'>

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="Code Strokes" />

    
  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/docco.min.css">
  
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>


  

  

  
</head>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-23129291-1', 'auto');
  ga('send', 'pageview');

</script>

<body>
	

	<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
  <div class="header">
    

    <h1 class="brand-title">CodeStrokes</h1>
    <h2 class="brand-tagline">Software Artistry</h2>

    <nav class="nav">
      <ul class="nav-list">
        <li class="nav-item"><span class="nav-item-separator">//</span><a href="http://codestrokes.com/">Home</a></li>
        
          <li class="nav-item"><span class="nav-item-separator">//</span><a href="/about/">About</a></li>
        
          <li class="nav-item"><span class="nav-item-separator">//</span><a href="/posts/">Blog</a></li>
        
          <li class="nav-item"><span class="nav-item-separator">//</span><a href="/series/">Series</a></li>
        
      </ul>
    </nav>

    
    <div class="social-buttons">
      
        
        <a href="https://github.com/JeremyLWright" target="_blank"><i class='fa fa-github'></i></a>
        
      
        
        <a href="https://www.twitter.com/jeremy_l_wright" target="_blank"><i class='fa fa-twitter'></i></a>
        
      
        
        <a href="https://www.linkedin.com/pub/jeremy-wright/5b/8/844" target="_blank"><i class='fa fa-linkedin'></i></a>
        
      
      
    </div>
    

  </div>
</div>

	
	

    <div class="content pure-u-1 pure-u-md-3-4">
		<a name="top"></a>
		

		
			
		    <div id="toc" class="pure-u-1 pure-u-md-1-4">
				<small class="toc-label">Contents</small>
		   	 	<nav id="TableOfContents">
<ul>
<li><a href="#implementing-minmax-with-properties:50cf44a3d7a8ca6a3d0b114540b5d3c2">Implementing MinMax with Properties</a></li>
<li><a href="#conclusion:50cf44a3d7a8ca6a3d0b114540b5d3c2">Conclusion</a></li>
</ul>
</nav>
		    </div>
		    
	    
  		<section class="post">
            <h1 class="post-title">
              <a href="/2015/07/property_driven_design_minmax/">Property Driven Design: MinMax</a>
            </h1>
            <h3 class="post-subtitle">
            	
            </h3>
            
            	<span class="post-date">
                	<span class="post-date-day"><sup>5</sup></span><span class="post-date-separator">/</span><span class="post-date-month">Jul</span> <span class="post-date-year">2015</span>
            	</span>
            	
            
            	
            		<span class="post-author-single">By <a class="post-author"  target="">Jeremy</a></span>
            		




            	
            

			
			
				<div class="post-categories">
				
					<a class="post-category post-category-c" href="http://codestrokes.com//categories/c">C&#43;&#43;</a>
				
					<a class="post-category post-category-property-driven-design" href="http://codestrokes.com//categories/property-driven-design">Property Driven Design</a>
				
				</div>
			

			

			

            

<p>I wrote an article on Property Driven Design about a year ago
(<a href="http://www.codestrokes.com/2014/09/property-testing-in-c/">http://www.codestrokes.com/2014/09/property-testing-in-c/</a>). Isocpp.org even
linked to it at one time (<a href="https://isocpp.org/blog/2014/12/property-testing">https://isocpp.org/blog/2014/12/property-testing</a>)
which was pretty cool. Recently, I uncovered a fantastic talk by Jessica Kerr
about property testing (<a href="https://www.youtube.com/watch?v=shngiiBfD80">https://www.youtube.com/watch?v=shngiiBfD80</a>). Kerr&rsquo;s
talk reinvigorated my passion in generated testing. Kerr presented the idea
(novel to me) that properties don&rsquo;t have to verify that an answer is correct.
Properties simply must reduce the size of the incorrect space. This may seem like
semantics, but sometimes it&rsquo;s much easier to verify something is not
a wild-ass-guess that if it is correct.
<img src="/img/Properties_solution_space.png" alt="sometimes_code_gives_you_a_wtf" />

Following Kerr&rsquo;s
references, I found a set of projects for a predicate-logic class
(<a href="http://www.cs.ou.edu/~rlpage/SEcollab/20projects/">http://www.cs.ou.edu/~rlpage/SEcollab/20projects/</a>). The class provides 20
projects. Each project breaks down the requirements and predicates the
functions should provide. This step-by-step example clarified many points
I misunderstood about property testing. This post will step through the design
of the first project minmax (<a href="http://www.cs.ou.edu/~rlpage/SEcollab/20projects/minmax.htm">http://www.cs.ou.edu/~rlpage/SEcollab/20projects/minmax.htm</a>) using C++. My primary goal for this article is to address a concern raised by a colleague, &ldquo;Does pulling in more complexity in terms of a fancy test generator actually increase quality?&rdquo; I believe it does when exercised properly.  All the code is available at <a href="https://github.com/JeremyLWright/property_driven_design/tree/master/01_minmax">github</a>, if you would like to follow along.</p>

<p>In her presentation, Kerr stated, &ldquo;..what is this answer? I don&rsquo;t know but
I can put a box around it!&rdquo; While this statement was made in jest it is quite
inspired. Example tests &mdash; the test typically used in unit tests (the FPGA/ASIC
guys call these Directed Tests) &mdash; draw individual points within the
correct region of the solution space. There are excellent structures for
drawing points in intelligent places, such as structured testing using McCabe
complexity, but in the end you are still drawing points. Properties on the
other hand draw boxes around the solution space. Notice that the properties do
not exclude all incorrect solutions. While this may seem as a defect to
property driven design, it is a simplification that makes properties resilient
to refactoring and maintenance cycles. Structured testing, for example, is
a whitebox method that looks as what test data will induce 100% block
coverage. As the code grows and changes over time, the predicates and
conditionals that influence the code coverage change. In a sense the points in
the correct solution place are always moving around. Properties however
operate at a higher level of abstraction. Properties allow one to say
&ldquo;solutions of <em>approximately this form</em> are likely correct.&rdquo; Properties then
can be made closer and closer to describe the overall shape of the correct
solution space. Its a powerful technique that I am increasingly enjoying in my
design work.</p>

<h1 id="implementing-minmax-with-properties:50cf44a3d7a8ca6a3d0b114540b5d3c2">Implementing MinMax with Properties</h1>

<p>Before we get started the term measure used in this problem statement means as
the ancient Greeks meant it, a segment which describes an integer number of
divisions of another number. Today we might use the word common-multiple.</p>

<p>Inspired by test-driven-design we&rsquo;ll start with defining a property for our
maximum function.</p>

<ol>
<li>Define a function, <em>maximum</em>, that delivers the largest value in a non-empty list of rational numbers.</li>
</ol>

<p>Using the autocheck library we can express this requirement as follows:</p>

<pre><code class="language-cpp">struct prop_max_element_t
{
    template&lt;
        typename SinglePassRange&gt;
    bool operator()(const SinglePassRange&amp; xs)
    {
        auto ref_max = std::max_element(std::cbegin(xs), std::cend(xs));
        const auto test_max = minmax::maximum(xs);
        return *ref_max == test_max;
    }
    
};

TEST(minmax, maximum_prop)
{
    autocheck::gtest_reporter rep;

    auto arbitrary = 
        autocheck::discard_if([](const std::vector&lt;size_t&gt;&amp; xs) -&gt; bool { return xs.size() == 0; },
        autocheck::make_arbitrary&lt;std::vector&lt;size_t&gt;&gt;());
        
    autocheck::check&lt;std::vector&lt;size_t&gt;&gt;(
            prop_max_element_t(),
            100,
            arbitrary,
            rep);
}
</code></pre>

<p>Lets start with the definition of the arbitrary generator:</p>

<pre><code class="language-cpp">    auto arbitrary = 
        autocheck::discard_if([](const std::vector&lt;size_t&gt;&amp; xs) -&gt; bool { return xs.size() == 0; },
        autocheck::make_arbitrary&lt;std::vector&lt;size_t&gt;&gt;());
</code></pre>

<p>The signature of an arbitrary generator is best read bottom to top.  The first
step generates a random vector of random length. The line above it throws away
vectors who&rsquo;s size is equal to zero. We will see later how to generate data
that meets our requirements, but sometimes its easier to just throw away some
data rather than try to generate only valid data.</p>

<p>With this property we can test our stub function:</p>

<pre><code class="language-cpp">namespace minmax
{

template &lt;typename SinglePassRange&gt;
typename SinglePassRange::value_type maximum(const SinglePassRange&amp; range)
{
    return 0; 
}
}
</code></pre>

<p>This generates a failed output as we expected</p>

<pre><code class="language-bash">[ RUN      ] minmax.maximum_prop
d:\property_driven_design\build\thirdparty\src\autocheck\include\autocheck\reporter.hpp(91): error: Value of: AUTOCHECK_SUCCESS
  Actual: false
Expected: true
Falsifiable, after 3 tests:
([2, 0])

[  FAILED  ] minmax.maximum_prop (3 ms)
</code></pre>

<p>From this we can implement our method</p>

<pre><code class="language-cpp">namespace minmax
{

template &lt;typename SinglePassRange&gt;
typename SinglePassRange::value_type maximum(const SinglePassRange&amp; range)
{
    //First Implementation
    //return 0; 
    return *std::max_element(
            std::begin(range),
            std::end(range));
}

}
</code></pre>

<p>and rerun our property</p>

<pre><code class="language-bash">[ RUN      ] minmax.maximum_prop
OK, passed 100 tests.
[       OK ] minmax.maximum_prop (14 ms)
</code></pre>

<p>This demonstrates another useful property of properties :-). The data passing
through our property test is randomly generated. Each time the test runs we
get different tests. Typing <em>make test</em> multiple times is actually a useful
thing, not just something you do to procrastinate at 4:45pm when you&rsquo;ve found
a new bug.</p>

<p>Also there is something viscerally satisfying about writing a single property
and seeing 100 tests passing.</p>

<p>Next we can verify the property given to us in the <a href="http://www.cs.ou.edu/~rlpage/SEcollab/20projects/minmax.htm">problem statement</a></p>

<ol>
<li>If xs is a non-empty true-list of rational numbers, then (maximum xs) is a rational number.</li>
</ol>

<p>Since C++ is a statically typed language this property may appear to be self
evident. However this demonstrates another benefit of property driven design.
We can document that we intend to only work with rational numbers. Then since
C++ is statically type we can validate the property statically, and any
maintenance programmer will fail to compile without modifying the test.</p>

<p>We can express this property as so</p>

<pre><code class="language-cpp">struct prop_maximum_should_give_rational_number_t
{
    template&lt;typename SinglePassRange&gt;
    bool operator()(const SinglePassRange&amp; xs)
    {
        static_assert(std::is_integral&lt;decltype(minmax::maximum(xs))&gt;::value, &quot;Maximum only works on rational numbers.&quot;);
        return std::is_integral&lt;decltype(minmax::maximum(xs))&gt;::value;
    }
};
</code></pre>

<p>This shows another pattern of testing I picked up from <a href="https://www.youtube.com/watch?v=sDMngNP7pOw">Bruce Tate</a>, tests should be named as a should-statement. This property here says: My property for maximum <em>should</em> give rational numbers. If this is ever falsified our test the static_assert() will fail compilation.</p>

<p>We can add another property that demonstrates the blackbox nature of property
testing.</p>

<p>&#50;. The value (maximum xs) occurs in the list xs</p>

<p>Properties as basic as this seem silly at first, but they serve a very useful
purpose. Recall the poorly drawn graphic from above. We are searching for bugs
in our program by defining bounds around the solution space. This property
states something very profound about our function. The output of our function
is dependent on the input. This trends the function toward referential
transparency. At a more basic level though, this might be a property one
starts with. Notice that if we implemented this property first, with our stub
function in place, our random generator would have falsified it easily with
any list where 0 was not a member.</p>

<p>We can express this property with autocheck as:</p>

<pre><code class="language-cpp">struct prop_maximum_should_return_a_value_from_the_list_t
{
    template &lt;typename SinglePassRange&gt;
    bool operator()(const SinglePassRange&amp; xs)
    {
        const auto m = minmax::maximum(xs);
        const auto is_present = std::find(
                std::begin(xs),
                std::end(xs),
                m);
        return is_present != std::end(xs);
    }
};
</code></pre>

<p>Simply put, if minmax::maximum returns some value m, that value must be
present in the list.  Notice again that m may be the minimum value in the
list. This property isn&rsquo;t checking for the complete correctness of the
function. It is testing one small aspect of the function&rsquo;s possible solution
space.</p>

<p>Next we can move on to our next function, <em>minimum_pair</em>, which we can
implement with a stub to always return the first element:</p>

<pre><code class="language-cpp">template &lt;typename SinglePassRange&gt;
measure_pair_t minimum_pair(const SinglePassRange&amp; xs)
{
    return *std::begin(xs);
}
</code></pre>

<p>To property test this function we&rsquo;ll need to teach autocheck how to generate
a <em>measure_pair_t</em>. We do this by specializing the generator function in the
autocheck namespace.</p>

<pre><code class="language-cpp">namespace autocheck
{

//Tell autocheck how to generate a measure_pair_t
template &lt;&gt;
class generator&lt;minmax::measure_pair_t&gt;
{
    public:
    using result_type = minmax::measure_pair_t;

    result_type operator()()
    {
        return this-&gt;operator()(0);
    }

    result_type operator()(size_t size)
    {
        auto rational_gen = generator&lt;std::size_t&gt;();
        return std::make_pair(rational_gen(size), rational_gen(size));
    }
};

//Tell autocheck how to display a measure_pair_t
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const minmax::measure_pair_t&amp; p)
{
    os &lt;&lt; &quot;{&quot; &lt;&lt; p.first &lt;&lt; &quot;, &quot; &lt;&lt; p.second &lt;&lt; &quot;}&quot;;
    return os;
}
}
</code></pre>

<p>Now autocheck can generate and display our specific type. Setup a property to
check.</p>

<p>&#52;. If xs is a non-empty true-list of measure pairs, then (minimum-pair xs) is a measure-pair.</p>

<p>To express this property we must first have a definition of a measure pair
(We&rsquo;ll see how this definition is not quite correct, but our properties will
sus that out quite quickly):</p>

<pre><code class="language-cpp">using measure_pair_t = std::pair&lt;std::size_t, std::size_t&gt;;

///Provided definition: measure pair: a two-element list whose first element, a rational number, is the measure of its other element
bool is_measure_pair(const measure_pair_t&amp; x)
{
    //A measure pair is a two element list, who's first element (a rational
    //number), is the measure of its other element
    const auto first_element_is_rational = std::is_integral&lt;decltype(x.first)&gt;::value;

    const auto other_element_is_measure_of_first = 
        //To be a measure the first value must be less-than the second.
        (x.first &lt; x.second)
        //And the second element must evenly divide the first element.
        &amp;&amp; (x.second % x.first == 0);
    return first_element_is_rational
        &amp;&amp; other_element_is_measure_of_first;
}
</code></pre>

<p>And our property to check that the return value from minimum pair should meet
the definition of a measure pair.</p>

<pre><code class="language-cpp">struct prop_minimum_pair_should_return_a_measure_pair_t
{
    bool operator()(const std::vector&lt;minmax::measure_pair_t&gt;&amp; xs) const
    {
        using namespace minmax;
        const auto test_pair = minimum_pair(xs);
        return is_measure_pair(test_pair);
    }
};
</code></pre>

<p>Executing this gives us, as expected due to our stub, a falsifiable case.</p>

<pre><code class="language-bash">[ RUN      ] MinMaxFixture.prop_minimum_pair_should_return_a_measure_pair
unknown file: error: SEH exception with code 0xc0000094 thrown in the test body.

[  FAILED  ] MinMaxFixture.prop_minimum_pair_should_return_a_measure_pair (1 ms)
</code></pre>

<p>Error 0xc0000094 is a divide by zero. Ah! Good catch autocheck. I know
I personally would not have exercised this using a directed test. This is
another strength of random testing. The random generators are not biased with
programmer intuition. Our requirements state that a measure-pair is always
non-zero so we will update the generator to exclude zero values.</p>

<pre><code class="language-cpp">namespace autocheck
{
template &lt;&gt;
class generator&lt;minmax::measure_pair_t&gt;
{
    public:
    using result_type = minmax::measure_pair_t;

    result_type operator()()
    {
        return this-&gt;operator()(0);
    }

    result_type operator()(const size_t size)
    {
        const auto non_zero_gen = [size]()
        {
            auto rational_gen = generator&lt;std::size_t&gt;();
            auto temp = rational_gen(size);
            if(temp == 0) //Skip over zero!
                return temp + 1;
            return temp;
        };
        const auto measure = non_zero_gen();
        const auto factor = non_zero_gen();
        return std::make_pair(measure*factor, measure);
    }
};
}
</code></pre>

<p>Now with zero values excluded we&rsquo;ll get a falsifiable test case:</p>

<pre><code class="language-bash">[ RUN      ] MinMaxFixture.prop_minimum_pair_should_return_a_measure_pair
d:\property_driven_design\build\thirdparty\src\autocheck\include\autocheck\reporter.hpp(91): error: Value of: AUTOCHECK_SUCCESS
  Actual: false
Expected: true
Falsifiable, after 1 tests:
([{1, 1}])

[  FAILED  ] MinMaxFixture.prop_minimum_pair_should_return_a_measure_pair (1 ms)
</code></pre>

<p>This test case demonstrates that our understand of the word measure wasn&rsquo;t
quite right when we implemented the <em>is_measure_pair</em> predicate. A value can
always be a measure of itself, i.e., a number always measures itself one time.
Notice that we still have a stub for our function. One school of thought is
that we are wasting time writing, and rewriting, test code before we&rsquo;ve even
worked on the code we&rsquo;re getting paid to write. But this failing test case is
evidence for a different perspective. The test code is working out our concept
of what the code needs to do. We the author would have written the function
incorrection the first time, considering we didn&rsquo;t implement the definition
correctly, e.g., we could translate a definition into C++ correctly, we
probably wouldn&rsquo;t have written some that that manipulates that definition
correctly. Nor, in our limited understanding of the problem, defined any</p>

<p>useful test data for our directed tests. John Hughes <a href="https://www.youtube.com/watch?v=FnjutUoNSmg">put it
best</a> when he state that property
testing is about comparing the specification to the code. The properties
encode the specification. The code does what it does. When the checker finds
a discrepancy it is the engineer&rsquo;s job to find where the defect lies. This is
very powerful. We, the engineer, aren&rsquo;t relegated to imagining test data for
our functions what will make it blow up. We simply describe concepts
(properties) of what we believe the specification is telling us to do. Then we
implement the code. If the two match then we the code probably matches the
specification. Its raises our level of thinking out of individual numbers, and
code paths to more abstract thinking, which is something humans do best. (I
liken this raising of thought similar to using ranges intead of indexes).</p>

<p>The problem is is that our definition doesn&rsquo;t include self-measures. We can
adjust it easily.</p>

<pre><code class="language-cpp">bool is_measure_pair(const measure_pair_t&amp; x)
{
    //A measure pair is a two element list, who's first element (a rational
    //number), is the measure of its other element
    const auto first_element_is_rational = std::is_integral&lt;decltype(x.first)&gt;::value;

    const auto other_element_is_measure_of_first = 
        //To be a measure the first value must be equal-to or less-than the second.
        (x.first == x.second) ||
        ((x.first &lt; x.second )
        //And the second element must evenly divide the first element.
        &amp;&amp; (x.second % x.first == 0));
    return first_element_is_rational
        &amp;&amp; other_element_is_measure_of_first;
}
</code></pre>

<p>Executing this generates a new failing case:</p>

<pre><code class="language-bash">[ RUN      ] MinMaxFixture.prop_minimum_pair_should_return_a_measure_pair
d:\property_driven_design\build\thirdparty\src\autocheck\include\autocheck\repor
ter.hpp(91): error: Value of: AUTOCHECK_SUCCESS
  Actual: false
Expected: true
Falsifiable, after 3 tests:
([{2, 1}, {2, 2}])

[  FAILED  ] MinMaxFixture.prop_minimum_pair_should_return_a_measure_pair (1 ms)
</code></pre>

<p>We can run it again to see if we get a different case:</p>

<pre><code class="language-bash">[ RUN      ] MinMaxFixture.prop_minimum_pair_should_return_a_measure_pair
d:\property_driven_design\build\thirdparty\src\autocheck\include\autocheck\reporter.hpp(91): error: Value of: AUTOCHECK_SUCCESS
  Actual: false
Expected: true
Falsifiable, after 7 tests:
([{4, 1}, {4, 2}, {2, 2}, {1, 1}])

[  FAILED  ] MinMaxFixture.prop_minimum_pair_should_return_a_measure_pair (1 ms)
</code></pre>

<p>This is awesome! Our failing test case is bigger now. Again to quote John
Hughes, &ldquo;<a href="https://www.youtube.com/watch?v=zi0rHwfiX1Q">This is progress! We are now passing for lists of size 1!</a>&rdquo; Our function is still implemented as a stub, so we can have some confidence that our test code is behaving properly. Let&rsquo;s implement our minimum_pair function:</p>

<pre><code class="language-cpp">template &lt;typename SinglePassRange&gt;
measure_pair_t minimum_pair(const SinglePassRange&amp; xs)
{
    return *std::min_element(
            std::begin(xs),
            std::end(xs),
            ::minmax::operator&lt;);
}
</code></pre>

<p>Executing our test code:</p>

<pre><code class="language-bash">D:\property_driven_design\build&gt;01_minmax
Running main() from gtest_main.cc
[==========] Running 7 tests from 3 test cases.
[----------] Global test environment set-up.
[----------] 1 test from minmax
[ RUN      ] minmax.maximum_directed
[       OK ] minmax.maximum_directed (0 ms)
[----------] 1 test from minmax (1 ms total)

[----------] 5 tests from MinMaxFixture
[ RUN      ] MinMaxFixture.prop_maximum_should_give_greatest_value
OK, passed 100 tests.
[       OK ] MinMaxFixture.prop_maximum_should_give_greatest_value (13 ms)
[ RUN      ] MinMaxFixture.prop_maximum_should_give_rational_number
OK, passed 100 tests.
[       OK ] MinMaxFixture.prop_maximum_should_give_rational_number (11 ms)
[ RUN      ] MinMaxFixture.prop_maximum_should_return_a_value_from_the_list
OK, passed 100 tests (2% trivial).
10% 10, odd-length.
10% 20, even-length.
10% 30, odd-length.
10% 40, even-length.
10% 50, odd-length.
10% 60, even-length.
10% 70, odd-length.
10% 80, even-length.
10% 90, odd-length.
9% 0, even-length.
[       OK ] MinMaxFixture.prop_maximum_should_return_a_value_from_the_list (24 ms)
[ RUN      ] MinMaxFixture.prop_minimum_pair_should_return_a_measure_pair
OK, passed 100 tests.
[       OK ] MinMaxFixture.prop_minimum_pair_should_return_a_measure_pair (20 ms)
[ RUN      ] MinMaxFixture.prop_minimum_pair_should_return_the_smallest_pair
OK, passed 100 tests.
[       OK ] MinMaxFixture.prop_minimum_pair_should_return_the_smallest_pair (23 ms)
[----------] 5 tests from MinMaxFixture (92 ms total)

[----------] 1 test from MinMaxDirected
[ RUN      ] MinMaxDirected.directed_minimum_pair_shouls_return_a_measure_pair
[       OK ] MinMaxDirected.directed_minimum_pair_shouls_return_a_measure_pair (0 ms)
[----------] 1 test from MinMaxDirected (0 ms total)

[----------] Global test environment tear-down
[==========] 7 tests from 3 test cases ran. (96 ms total)
[  PASSED  ] 7 tests.
</code></pre>

<p>Running this multiple times generates no failing test cases.</p>

<h1 id="conclusion:50cf44a3d7a8ca6a3d0b114540b5d3c2">Conclusion</h1>

<p>So a few real-world metrics. I wrote this code and properties in 3 hours. The
requirements were relatively simple, but I suspect that using example tests
would have resulted in a similar completion time. Additionally, I suspect, my
directed tests would have found more defects near the end of my development
rather than the beginning. I felt this affect as an acceleration. I found feel
as I closed each property that I had fewer defects in the code I previously
thought was done. This is a big confidence booster in my opinion.
Additionally, another pattern I learned from John Hughes, that I didn&rsquo;t
explicitly describe here but you can see in the code, save failed tests.
A failing test is gold! When the random generator uncovers something
interesting save it as a directed test. Then fix the failure and leave the
directed test behind. It will be a reminder of a corner case you missed. Plus
some developers like to see examples tests, even random ones.</p>

<p>In this post I walked through a property-driven-design approach to a simple
numerical problem. In intended to show something more interesting that the
<em>reverse(reverse(list)) == list</em> example, and something less contrived than my
previous post on property testing. I look forward to any feedback on this
post.</p>

	
			

			
				<div class="tags-list">
					<span class="dark-red">Tags</span><span class="decorative-marker">//</span>
					
	                <a class="post-tag post-tag-property-testing" href="http://codestrokes.com//tags/property-testing">property-testing</a>,
	                
	                <a class="post-tag post-tag-example" href="http://codestrokes.com//tags/example">example</a>,
	                
	                <a class="post-tag post-tag-tutorial" href="http://codestrokes.com//tags/tutorial">tutorial</a>,
	                
				</div>
			

			
				<div class="paging">
					<span class="paging-label">More Reading</span>
					

					
					<div class="paging-older">
						<span class="dark-red">Older</span><span class="decorative-marker">//</span>
			            <a class="paging-link" href="/2015/06/converting-to-static-blog/">Recasting how I blog</a>
		            </div>
		            
	            </div>
            
          </section>
          
          	<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'codestrokes2';
    var disqus_identifier = 'http:\/\/codestrokes.com\/2015\/07\/property_driven_design_minmax\/';
    var disqus_title = 'Property Driven Design: MinMax';
    var disqus_url = 'http:\/\/codestrokes.com\/2015\/07\/property_driven_design_minmax\/';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
          
        
      <div class="footer">
	<hr class="thin" />
	<div class="pure-menu pure-menu-horizontal pure-menu-open">
		<ul class="footer-menu">
		
			<li><a href="/posts/">Blog</a></li>
		
			<li><a href="/series/">Series</a></li>
		
		</ul>
	</div>

	<p>&copy; 2015. All rights reserved. </p>
</div>
    </div>
  </div>
	

	

  
</body>
</html>