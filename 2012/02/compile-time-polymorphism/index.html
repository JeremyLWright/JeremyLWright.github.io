<!DOCTYPE html>
<html lang="en">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="">
<meta name="author" content="">

    <title>Code Strokes</title>

<link href="" rel="alternate" type="application/rss+xml" title="Code Strokes" />
<link href="" rel="feed" type="application/rss+xml" title="Code Strokes" />

<link href="//netdna.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css" media="all" rel="stylesheet">


<link rel="stylesheet" type="text/css" href="/css/default.css" />
<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="//code.cdn.mozilla.net/fonts/fira.css">
<link href='//fonts.googleapis.com/css?family=Kaushan+Script' rel='stylesheet' type='text/css'>



<link rel="apple-touch-icon" sizes="57x57" href="/images/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/images/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/images/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/images/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/images/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/images/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/images/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/images/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="192x192"  href="/images/android-icon-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
<link rel="manifest" href="/images/manifest.json">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="/images/ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">
<link rel="stylesheet" type="text/css" href="/css/styles/default.css" />
<script src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

</head>
<body id="page-top" class="index">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-23129291-1', 'auto');
  ga('send', 'pageview');

</script>


<nav class="navbar navbar-default navbar-fixed-top navbar-shrink">
	<div class="container">
		
		<div class="navbar-header page-scroll">
			<button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
    <a class="navbar-brand page-scroll" href="/">Code Strokes</a>
		</div>

		
		<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
			<ul class="nav navbar-nav navbar-right">
				<li class="hidden">
                <a href="/"></a>
                </li>
                <li><a href="/about/">About</a></li>
                
                <li><a href="/"></a></li>
                
                <li><a href="/posts">posts</a></li>
                
			
			</ul>
		</div>
		
	</div>
	
</nav>


<section id="content">
    <div class="container">
        <div class="row">
            <div class="col-lg-12 text-center">
                <h1><a href="http://localhost:1313/2012/02/compile-time-polymorphism/">Compile-Time Polymorphism</a></h1>
            </div>
            <span class="section-subheading text-muted">Sun, Feb 5, 2012</span>
            <div class="post">
                

<p>Polymorphism is a tool in object orientation, which allows us to model behavior, while simultaneously leverage existing code. Polymorphism allows is behavior reuse.  In C++ polymorphism, comes in 2 flavors, the standard runtime variant, and a curious compile time variant.  Runtime polymorphism, like Java, leverages virtual functions to dynamically bind[1. With virtual functions the compiler doesn&rsquo;t know which method to call until runtime. In C++ this is implemented with the <a href="http://en.wikipedia.org/wiki/Virtual_method_table">virtual method table</a>] a method at the call site. Compile Time polymorphism uses templates, to bind at compile time, thus negating the performance affect of virtual functions.</p>

<!-- more -->

<p>Polymorphism is a powerful concept. Polymorphism is a powerful tool in object-orientation, allowing one to realistically model the behavior or structure of some entity in software. This is key to any software design. Regardless, of idioms, language, paradigm, a realistic model is essential to a good design. If follow every best practice in software design, but your system doesn&rsquo;t accurately reflect the real-world model, your software will be difficult to work with, and it will be impossible to bring new people on your project.  An accurate portrayal is required.</p>

<p>C++ affords us 2 forms of g: compile-time [2. Compile-Time polymorphism is also known as static polymorphism. I, however find this nomenclature confusing.  &rdquo;static dynamicism&rdquo;&hellip;. Um, what?], and runtime.  Runtime is the most straightforward, and uses virtual functions.  However, as we&rsquo;ll see later, virtual function have their own performance costs.</p>

<p><a href="http://www.codestrokes.com/wp-content/uploads/2012/02/SuperSimplePolymorphism.png.jpg.jpeg"><img src="http://www.codestrokes.com/wp-content/uploads/2012/02/SuperSimplePolymorphism.png.jpg.jpeg" alt="" />
</a></p>

<p>We&rsquo;re going to implement this very simple hierarchy, to demonstrate polymorphism is its most basic form.</p>

<pre><code>struct Base {
    Base (){}
    virtual ~Base (){}
    virtual void DoSomething(){
        cout &lt;&lt; &quot;Hello From Base.&quot; &lt;&lt; endl;
    }
};

struct Child : public Base {
    Child (){}
    virtual ~Child (){}
    virtual void DoSomething() {
        cout &lt;&lt; &quot;Hello from Child.&quot; &lt;&lt; endl;
    }
};
</code></pre>

<p>Using the following driver code.</p>

<pre><code>int main(int argc, char const *argv[]){   
    Base* b = new Child();
    b-&gt;DoSomething();
    delete b;
}




}
</code></pre>

<p>Produces the following output:</p>

<pre><code>bash $ ./a.out
Hello from Child
</code></pre>

<p>This works, and its a familiar idiom. However virtual functions have a some performance issues. Since the call isn&rsquo;t bound until until runtime, the methods cannot be inlined, and will probably incur a cache miss [1. <a href="http://coldattic.info/shvedsky/pro/blogs/a-foo-walks-into-a-bar/posts/3">A foo walks into a bar</a>] , which on modern processors with the very deep caches is a very costly effect.</p>

<p><a href="http://www.codestrokes.com/wp-content/uploads/2012/02/Untitled-1.png"><img src="http://www.codestrokes.com/wp-content/uploads/2012/02/Untitled-1.png" alt="" />
</a></p>

<p>Secondly, even with cacheing aside virtual functions are about 2.5 times slower than direct function calls; where as inlining, i.e. zero-function overhead is about 20 times faster [1. <a href="http://assemblyrequired.crashworks.org/2009/01/19/how-slow-are-virtual-functions-really/">How Slow Are Virtual Functions Really</a>]. So this is a major issue is performance critical code, such as games. The EA directly states that virtual functions forbidden in their code [1. <a href="http://assemblyrequired.crashworks.org/2008/12/22/ea-stl-prevents-memory-leaks/#more-92">How the EA prevents Memory Leaks</a>].  However, polymorphism is a powerful tool. Are we relegated to a &ldquo;lower&rdquo; form of Object-Orientation with writing performance critical code? No. In fact the opposite is true.  C++&rsquo;s template system is powerful and allows us to add dnasicm at compile time.</p>

<p>We can implement the same behavior as the UML figure above using templates. This improves the performance of our code in two ways. Firstly, by omitting virtual function we pickup a ~2.5x boost. Secondly, by using composition instead of inheritance we also get a small bump, and the compiler is more likely to inline the &ldquo;inner&rdquo; function.</p>

<pre><code>template &lt;typename ChildType&gt;
struct Base {
    Base (){}
    virtual ~Base2 (){}
    void DoSomething() {
        myChild.DoSomething(); // This is the &quot;inner&quot; function.
    }
private:
    ChildType myChild;
};

struct Child /* Notice the lack of inheritance here */{
    Child () {}
    virtual ~Child(){}
    void DoSomething(){
        cout &lt;&lt; &quot;Hello from Child.&quot; &lt;&lt; endl;
    }
};
</code></pre>

<p>Our driver is similar to before, except for the instantiation. Instead of inheriting behavior from a base class and overriding it, the Child, or implementing type, is passed in as an instantiation argument. This creates a new type, which is the dynamic behavior we want. Using the following driver code, we achieve the same output as before.</p>

<pre><code>int main(int argc, char const *argv[]){   
    Base&lt;Child&gt;* b = new Base&lt;Child2&gt;();
    b-&gt;DoSomething();
    delete b;
}
</code></pre>

<p>C++11 (-std=c++0x in gcc4.6) allows one 1 more improvement in the driver code to prevent memory leaks.</p>

<pre><code>int main(int argc, char const *argv[]){   
auto b2 = make_shared&lt;Base2&lt;Child2&gt; &gt;();
b2-&gt;DoSomething();
//Notice we don't have to call delete. Woot, exception safety!
}
</code></pre>

<p>So polymorphism is a powerful tool for creating dynamicism in programs, however with the inherent [1. Pun intended] performance issues the standard form of polymorphism is not the tool for every job. C++ templates allow use a manageable way to achieve similar behavior at compile time!</p>

<hr />

<h4 id="references:e250069d864db99c70bebd39675460a8">References</h4>

            </div>
        </div>

 
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'codestrokes2'; 

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        

     </div>
</section> 
     
<script src="//ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>



<script data-no-instant>document.write('<script src="http://'
        + (location.host || 'localhost').split(':')[0]
		+ ':1313/livereload.js?mindelay=10"></'
        + 'script>')</script></body>
</html>

